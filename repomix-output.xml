This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
default.db
docs/flask-clean-architecture.md
README.md
scripts/check_imports.py
scripts/run_postgres.sh
scripts/seed_users.py
scripts/test_login.js
scripts/test_login.py
seed_all_data.py
src/api/controllers/academic_year_controller.py
src/api/controllers/ai_controller.py
src/api/controllers/assessment_clo_controller.py
src/api/controllers/assessment_component_controller.py
src/api/controllers/assessment_scheme_controller.py
src/api/controllers/auth_controller.py
src/api/controllers/clo_plo_mapping_controller.py
src/api/controllers/dashboard_controller.py
src/api/controllers/department_controller.py
src/api/controllers/faculty_controller.py
src/api/controllers/file_controller.py
src/api/controllers/notification_controller.py
src/api/controllers/program_controller.py
src/api/controllers/program_outcome_controller.py
src/api/controllers/role_controller.py
src/api/controllers/rubric_controller.py
src/api/controllers/student_controller.py
src/api/controllers/subject_controller.py
src/api/controllers/subject_relationship_controller.py
src/api/controllers/syllabus_clo_controller.py
src/api/controllers/syllabus_comment_controller.py
src/api/controllers/syllabus_controller.py
src/api/controllers/syllabus_material_controller.py
src/api/controllers/system_setting_controller.py
src/api/controllers/teaching_plan_controller.py
src/api/controllers/user_controller.py
src/api/middleware.py
src/api/requests.py
src/api/responses.py
src/api/routes.py
src/api/schemas/...  # Marshmallow schemas
src/api/schemas/academic_year_schema.py
src/api/schemas/assessment_clo_mapping_schema.py
src/api/schemas/assessment_component_schema.py
src/api/schemas/assessment_scheme_schema.py
src/api/schemas/base_schema.py
src/api/schemas/clo_plo_mapping_schema.py
src/api/schemas/department_schema.py
src/api/schemas/faculty_schema.py
src/api/schemas/file_schema.py
src/api/schemas/notification_schema.py
src/api/schemas/program_outcome_schema.py
src/api/schemas/program_schema.py
src/api/schemas/role_schema.py
src/api/schemas/rubric_schema.py
src/api/schemas/student_schema.py
src/api/schemas/subject_relationship_schema.py
src/api/schemas/subject_schema.py
src/api/schemas/syllabus_clo_schema.py
src/api/schemas/syllabus_comment_schema.py
src/api/schemas/syllabus_detail_schema.py
src/api/schemas/syllabus_material_schema.py
src/api/schemas/syllabus_schema.py
src/api/schemas/system_setting_schema.py
src/api/schemas/teaching_plan_schema.py
src/api/schemas/user_schema.py
src/api/schemas/user.py
src/api/schemas/workflow_log_schema.py
src/api/swagger.py
src/app_logging.py
src/app.py
src/config.py
src/cors.py
src/create_app.py
src/default.db
src/dependency_container.py
src/domain/constants.py
src/domain/exceptions.py
src/domain/models/...  # Business logic models
src/domain/models/user.py
src/error_handler.py
src/infrastructure/databases/__init__.py
src/infrastructure/databases/base.py
src/infrastructure/databases/mssql.py
src/infrastructure/databases/mysql.py
src/infrastructure/models/__init__.py
src/infrastructure/models/academic_year_model.py
src/infrastructure/models/ai_auditlog_model.py
src/infrastructure/models/assessment_clo_model.py
src/infrastructure/models/assessment_component_model.py
src/infrastructure/models/assessment_scheme_model.py
src/infrastructure/models/clo_plo_mapping_model.py
src/infrastructure/models/department_model.py
src/infrastructure/models/faculty_model.py
src/infrastructure/models/file_model.py
src/infrastructure/models/notification_model.py
src/infrastructure/models/notification_template_model.py
src/infrastructure/models/program_model.py
src/infrastructure/models/program_outcome_model.py
src/infrastructure/models/role_model.py
src/infrastructure/models/rubric_model.py
src/infrastructure/models/student_report_model.py
src/infrastructure/models/student_subscription_model.py
src/infrastructure/models/subject_model.py
src/infrastructure/models/subject_relationship_model.py
src/infrastructure/models/syllabus_clo_model.py
src/infrastructure/models/syllabus_comment_model.py
src/infrastructure/models/syllabus_current_workflow.py
src/infrastructure/models/syllabus_material_model.py
src/infrastructure/models/syllabus_model.py
src/infrastructure/models/system_auditlog_model.py
src/infrastructure/models/system_setting_model.py
src/infrastructure/models/teaching_plan_model.py
src/infrastructure/models/user_model.py
src/infrastructure/models/user_role_model.py
src/infrastructure/models/workflow_log_model.py
src/infrastructure/models/workflow_state_model.py
src/infrastructure/models/workflow_transition_model.py
src/infrastructure/repositories/academic_year_repository.py
src/infrastructure/repositories/ai_auditlog_repository.py
src/infrastructure/repositories/assessment_clo_repository.py
src/infrastructure/repositories/assessment_component_repository.py
src/infrastructure/repositories/assessment_scheme_repository.py
src/infrastructure/repositories/clo_plo_mapping_repository.py
src/infrastructure/repositories/department_repository.py
src/infrastructure/repositories/faculty_repository.py
src/infrastructure/repositories/file_repository.py
src/infrastructure/repositories/notification_repository.py
src/infrastructure/repositories/program_outcome_repository.py
src/infrastructure/repositories/program_repository.py
src/infrastructure/repositories/role_repository.py
src/infrastructure/repositories/rubric_repository.py
src/infrastructure/repositories/student_report_repository.py
src/infrastructure/repositories/student_subscription_repository.py
src/infrastructure/repositories/subject_relationship_repository.py
src/infrastructure/repositories/subject_repository.py
src/infrastructure/repositories/syllabus_clo_repository.py
src/infrastructure/repositories/syllabus_comment_repository.py
src/infrastructure/repositories/syllabus_material_repository.py
src/infrastructure/repositories/syllabus_repository.py
src/infrastructure/repositories/system_setting_repository.py
src/infrastructure/repositories/teaching_plan_repository.py
src/infrastructure/repositories/user_repository.py
src/infrastructure/repositories/workflow_log_repository.py
src/infrastructure/services/...  # Services that use third party libraries or services (e.g. email service)
src/migrations
src/README.md
src/requirements.txt
src/scripts/import_check.py
src/services/...  # Services for interacting with the domain (business logic)
src/services/academic_year_service.py
src/services/ai_service.py
src/services/assessment_clo_service.py
src/services/assessment_component_service.py
src/services/assessment_scheme_service.py
src/services/clo_plo_mapping_service.py
src/services/department_service.py
src/services/faculty_service.py
src/services/file_service.py
src/services/notification_service.py
src/services/program_outcome_service.py
src/services/program_service.py
src/services/role_service.py
src/services/rubric_service.py
src/services/student_service.py
src/services/subject_relationship_service.py
src/services/subject_service.py
src/services/syllabus_clo_service.py
src/services/syllabus_comment_service.py
src/services/syllabus_material_service.py
src/services/syllabus_service.py
src/services/system_setting_service.py
src/services/teaching_plan_service.py
src/services/user_service.py
src/swagger_config.json
src/tests/test_file_service.py
src/tests/test_program_outcome_service.py
src/tests/test_smoke_imports.py
src/tests/test_syllabus_service.py
tests/e2e_test_flow.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[codz]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py.cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock
#poetry.toml

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#   pdm recommends including project-wide configuration in pdm.toml, but excluding .pdm-python.
#   https://pdm-project.org/en/latest/usage/project/#working-with-version-control
#pdm.lock
#pdm.toml
.pdm-python
.pdm-build/

# pixi
#   Similar to Pipfile.lock, it is generally recommended to include pixi.lock in version control.
#pixi.lock
#   Pixi creates a virtual environment in the .pixi directory, just like venv module creates one
#   in the .venv directory. It is recommended not to include this directory in version control.
.pixi

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.envrc
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Abstra
# Abstra is an AI-powered process automation framework.
# Ignore directories containing user credentials, local state, and settings.
# Learn more at https://abstra.io/docs
.abstra/

# Visual Studio Code
#  Visual Studio Code specific template is maintained in a separate VisualStudioCode.gitignore 
#  that can be found at https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore
#  and can be added to the global gitignore or merged into this file. However, if you prefer, 
#  you could uncomment the following to ignore the entire vscode folder
# .vscode/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc

# Cursor
#  Cursor is an AI-powered code editor. `.cursorignore` specifies files/directories to
#  exclude from AI features like autocomplete and code analysis. Recommended for sensitive data
#  refer to https://docs.cursor.com/context/ignore-files
.cursorignore
.cursorindexingignore

# Marimo
marimo/_static/
marimo/_lsp/
__marimo__/
</file>

<file path="docs/flask-clean-architecture.md">
# Architecture

```bash
    ‚îú‚îÄ‚îÄ migrations
    ‚îú‚îÄ‚îÄ scripts
    ‚îÇ   ‚îî‚îÄ‚îÄ run_postgres.sh
    ‚îú‚îÄ‚îÄ src
    ‚îÇ   ‚îú‚îÄ‚îÄ api
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...  # controllers for the api
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schemas
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...  # Marshmallow schemas
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ responses.py
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ requests.py
    ‚îÇ   ‚îú‚îÄ‚îÄ infrastructure
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...  # Services that use third party libraries or services (e.g. email service)
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ databases
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...  # Database adapaters and initialization
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repositories
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...  # Repositories for interacting with the databases
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...  # Database models
    ‚îÇ   ‚îú‚îÄ‚îÄ domain
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ constants.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exceptions.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...  # Business logic models
    ‚îÇ   ‚îú‚îÄ‚îÄ services
    ‚îÇ   ‚îÇ    ‚îî‚îÄ‚îÄ ...  # Services for interacting with the domain (business logic)
    ‚îÇ   ‚îú‚îÄ‚îÄ app.py
    ‚îÇ   ‚îú‚îÄ‚îÄ config.py
    ‚îÇ   ‚îú‚îÄ‚îÄ cors.py
    ‚îÇ   ‚îú‚îÄ‚îÄ create_app.py
    ‚îÇ   ‚îú‚îÄ‚îÄ dependency_container.py
    ‚îÇ   ‚îú‚îÄ‚îÄ error_handler.py
    ‚îÇ   ‚îî‚îÄ‚îÄ logging.py
```

## Domain Layer

## Services Layer

## Infrastructure Layer

## ORM ƒê√£ ƒë∆∞·ª£c tri·ªÉn khai trong Flask python 
√Ånh x·∫° c√°c class python --> Table CSDL
</file>

<file path="README.md">
# Syllabus Management System (SMD) - Backend ‚úÖ

## Description
A RESTful API built with **Flask** following a **Clean Architecture** style for managing university course syllabuses. The backend supports creating syllabuses, defining Course Learning Outcomes (CLOs), managing teaching plans, assessment schemes, rubrics, and an approval workflow with history logging.

---

## Tech Stack üß∞
- **Framework:** Flask
- **Database:** MS SQL Server (accessed via SQLAlchemy + pymssql)
- **Architecture:** Clean Architecture (Controller ‚Üí Service ‚Üí Repository ‚Üí Model)
- **DI Container:** dependency-injector
- **Serialization/Validation:** Marshmallow
- **Documentation:** Swagger UI (Flasgger)

---

## Key Features ‚ú®
- **Master Data Management:** Faculties, Departments, Subjects, Academic Years, Programs, Users, Roles
- **Syllabus Management:** Create / Update syllabus header and general info (time allocation, prerequisites, versioning)
- **Syllabus Components:**
  - **CLOs:** Manage Course Learning Outcomes
  - **Materials:** Manage textbooks and references
  - **Teaching Plan:** Weekly schedule and activities
- **Assessment System:**
  - Define **Schemes** (Progress, Midterm, Final)
  - Define **Components** (Quiz, Lab, Exam)
  - **Rubrics:** Detailed scoring criteria
  - **Mapping:** Map assessment components to CLOs
- **Workflow:** Submit ‚Üí Approve / Reject process with **WorkflowLog** history
- **Auth (Demo):** Basic auth controller returning a demo token; token decorator available for protecting endpoints

---

## Project Structure (brief)
```
src/
‚îú‚îÄ api/                # HTTP controllers, schemas, middleware, swagger
‚îÇ  ‚îú‚îÄ controllers/     # Blueprints for each resource
‚îÇ  ‚îî‚îÄ schemas/         # Marshmallow schemas
‚îú‚îÄ services/           # Business logic (services)
‚îú‚îÄ infrastructure/     # DB models, repositories, DB adapters
‚îÇ  ‚îú‚îÄ models/
‚îÇ  ‚îî‚îÄ repositories/
‚îú‚îÄ domain/             # Domain models/constants/exceptions
‚îú‚îÄ scripts/            # Helper scripts (seed data, etc.)
‚îú‚îÄ dependency_container.py  # DI wiring
‚îî‚îÄ app.py              # App factory + blueprint registration
```

## Setup & Installation ‚öôÔ∏è

Follow these steps to get the backend running locally.

1. Clone the repository

```bash
git clone https://github.com/vux311/Backend_SMD.git
cd Backend_SMD
```

2. Create a virtual environment and activate it

```bash
python -m venv .venv
# Windows (PowerShell)
.venv\Scripts\Activate.ps1
# macOS / Linux
source .venv/bin/activate
```

3. Install dependencies

```bash
pip install -r src/requirements.txt
```

4. Environment variables

Create a `.env` file inside the `src/` folder containing at least:

```env
# Flask
SECRET_KEY=your_secret_key

# Database (SQLAlchemy URL)
DATABASE_URI=mssql+pymssql://sa:YourPassword@127.0.0.1:1433/YourDatabase
```

5. Database (MS SQL Server) via Docker (example)

```bash
docker pull mcr.microsoft.com/mssql/server:2025-latest
docker run -e "ACCEPT_EULA=Y" -e "MSSQL_SA_PASSWORD=YourPassword" -p 1433:1433 --name sql1 -d mcr.microsoft.com/mssql/server:2025-latest
```

---

## Seeding Data (Important) üå±

A seed script creates default roles and an example syllabus (Admin, Lecturer, Subject, sample CLOs, materials).

Run from repository root:

```bash
python -m src.scripts.seed_users
```

The script is idempotent and can be re-run safely.

---

## Running the App ‚ñ∂Ô∏è

Start the development server:

```bash
python src/app.py
```

- Default port: **9999**
- Swagger UI: **http://localhost:9999/docs**

---

## API Documentation

Interactive API specification is available at the Swagger UI endpoint above. Use it to explore endpoints, request/response schemas, and try sample requests.

---

## Project Notes & Next Steps üí°

- Authentication included in a demo form (dummy tokens). For production, integrate full JWT-based auth and role-based access control.
- Recommended: add automated tests (unit + integration) and CI checks (linting/tests) for PR validation.

---

If you'd like, I can add a CONTRIBUTING guide, CI pipeline, or a small integration test that exercises the workflow (submit ‚Üí approve/reject).
</file>

<file path="scripts/check_imports.py">
import importlib
modules = [
    'src.infrastructure.databases',
    'src.api.routes',
    'src.create_app'
]

for m in modules:
    try:
        importlib.import_module(m)
        print(f'{m}: OK')
    except Exception as e:
        print(f'{m}: {type(e).__name__}: {e}')
</file>

<file path="scripts/run_postgres.sh">
#!/bin/bash

# Function to check if PostgreSQL is running
is_postgres_running() {
    pg_isready -q
    return $?
}

# Start PostgreSQL if it's not already running
if ! is_postgres_running; then
    echo "PostgreSQL is not running. Starting it now..."
    pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start
else
    echo "PostgreSQL is already running."
fi

# Create the database if it doesn't exist
if ! psql -lqt | cut -d \| -f 1 | grep -qw dbname; then
    createdb dbname
fi
</file>

<file path="scripts/seed_users.py">
from dependency_container import Container
from datetime import date


def get_or_create(service, list_method_name, check_attr, check_value, create_method_name, create_data):
    list_method = getattr(service, list_method_name)
    for item in list_method():
        if getattr(item, check_attr) == check_value:
            return item
    create_method = getattr(service, create_method_name)
    return create_method(create_data)


def seed():
    container = Container()

    # Services
    role_service = container.role_service()
    user_service = container.user_service()
    faculty_service = container.faculty_service()
    department_service = container.department_service()
    academic_year_service = container.academic_year_service()
    program_service = container.program_service()
    subject_service = container.subject_service()
    syllabus_service = container.syllabus_service()
    syllabus_clo_service = container.syllabus_clo_service()
    syllabus_material_service = container.syllabus_material_service()

    # 1) Roles
    admin_role = role_service.get_by_name('ADMIN') or role_service.create_role({'name': 'ADMIN', 'description': 'ADMIN role'})
    print('‚úÖ  Role:', admin_role.name)
    lecturer_role = role_service.get_by_name('LECTURER') or role_service.create_role({'name': 'LECTURER', 'description': 'LECTURER role'})
    print('‚úÖ  Role:', lecturer_role.name)

    # 2) Users
    admin = user_service.get_by_username('admin')
    if not admin:
        admin = user_service.create_user({'username': 'admin', 'email': 'admin@example.com', 'full_name': 'Admin User', 'password': 'password123', 'is_active': True})
        print('‚úÖ  Created User: admin')
    else:
        print('‚úÖ  Found User: admin')

    lecturer = user_service.get_by_username('lecturer')
    if not lecturer:
        lecturer = user_service.create_user({'username': 'lecturer', 'email': 'lecturer@example.com', 'full_name': 'Lecturer User', 'password': 'password123', 'is_active': True})
        print('‚úÖ  Created User: lecturer')
    else:
        print('‚úÖ  Found User: lecturer')

    # Assign roles idempotently
    session = container.db_session()
    from infrastructure.models.user_role_model import UserRole

    def ensure_role(user, role):
        if not session.query(UserRole).filter_by(user_id=user.id, role_id=role.id).first():
            try:
                session.add(UserRole(user_id=user.id, role_id=role.id))
                session.commit()
                print(f"‚úÖ  Assigned role {role.name} to user {user.username}")
            except Exception:
                session.rollback()

    ensure_role(admin, admin_role)
    ensure_role(lecturer, lecturer_role)

    # 3) Faculty & Department
    faculty = get_or_create(faculty_service, 'list_faculties', 'code', 'FIT', 'create_faculty', {'code': 'FIT', 'name': 'Faculty of Information Technology'})
    print(f"‚úÖ  Faculty: {faculty.code} - {faculty.name}")

    department = None
    # department needs faculty_id
    for d in department_service.list_departments():
        if d.code == 'SE' and d.faculty_id == faculty.id:
            department = d
            break
    if not department:
        department = department_service.create_department({'faculty_id': faculty.id, 'code': 'SE', 'name': 'Software Engineering'})
        print('‚úÖ  Created Department: SE')
    else:
        print('‚úÖ  Found Department: SE')

    # 4) Academic Year, Program, Subject
    academic_year = get_or_create(academic_year_service, 'list_academic_years', 'code', '2025-2026', 'create_academic_year', {'code': '2025-2026', 'start_date': date(2025,9,1), 'end_date': date(2026,6,30)})
    print(f"‚úÖ  AcademicYear: {academic_year.code}")

    program = get_or_create(program_service, 'list_programs', 'name', 'Software Engineering K18', 'create_program', {'department_id': department.id, 'name': 'Software Engineering K18', 'total_credits': 120})
    print(f"‚úÖ  Program: {program.name}")

    subject = None
    for s in subject_service.list_subjects():
        if s.code == 'SWT301' and s.department_id == department.id:
            subject = s
            break
    if not subject:
        subject = subject_service.create_subject({'department_id': department.id, 'code': 'SWT301', 'name_vi': 'Gi·ªõi thi·ªáu K·ªπ thu·∫≠t Ph·∫ßn m·ªÅm', 'name_en': 'Introduction to Software Engineering', 'credits': 3})
        print('‚úÖ  Created Subject: SWT301')
    else:
        print('‚úÖ  Found Subject: SWT301')

    # 5) Syllabus
    syllabus = None
    for sy in syllabus_service.list_syllabuses():
        if sy.subject_id == subject.id and sy.program_id == program.id and sy.academic_year_id == academic_year.id:
            syllabus = sy
            break
    if not syllabus:
        syllabus = syllabus_service.create_syllabus({'subject_id': subject.id, 'program_id': program.id, 'academic_year_id': academic_year.id, 'lecturer_id': lecturer.id, 'version': '1.0'})
        print(f"‚úÖ  Created Syllabus ID: {syllabus.id}")
    else:
        print(f"‚úÖ  Found Syllabus ID: {syllabus.id}")

    # 6) Syllabus Details - CLOs
    existing_clos = {c.code for c in syllabus_clo_service.get_by_syllabus(syllabus.id)}
    clos_to_add = [
        {'code': 'CLO1', 'description': 'Explain software lifecycle.'},
        {'code': 'CLO2', 'description': 'Apply software requirements engineering.'},
        {'code': 'CLO3', 'description': 'Design basic software architecture.'},
    ]
    for clo in clos_to_add:
        if clo['code'] not in existing_clos:
            item = syllabus_clo_service.create_clo({'syllabus_id': syllabus.id, **clo})
            print(f"‚úÖ  Added CLO: {item.code}")
        else:
            print(f"‚úÖ  CLO exists: {clo['code']}")

    # Materials
    existing_mats = {m.title for m in syllabus_material_service.get_by_syllabus(syllabus.id)}
    mats_to_add = [
        {'type': 'MAIN', 'title': 'Software Engineering (Textbook)', 'author': 'Ian Sommerville', 'publisher': 'Pearson', 'isbn': '1234567890', 'syllabus_id': syllabus.id},
        {'type': 'REFERENCE', 'title': 'Design Patterns', 'author': 'Gamma et al.', 'publisher': 'Addison-Wesley', 'isbn': '0987654321', 'syllabus_id': syllabus.id},
    ]
    for mat in mats_to_add:
        if mat['title'] not in existing_mats:
            item = syllabus_material_service.create_material(mat)
            print(f"‚úÖ  Added Material: {item.title}")
        else:
            print(f"‚úÖ  Material exists: {mat['title']}")

    # Teaching Plans
    teaching_plan_service = container.teaching_plan_service()
    existing_weeks = {p.week for p in teaching_plan_service.list_plans_for_syllabus(syllabus.id)}
    plans_to_add = [
        {'week': 1, 'topic': 'Introduction to Software Engineering', 'activity': 'Lecture', 'assessment': 'Quiz', 'syllabus_id': syllabus.id},
        {'week': 2, 'topic': 'Software Process Models', 'activity': 'Lecture', 'assessment': 'Assignment 1', 'syllabus_id': syllabus.id},
        {'week': 3, 'topic': 'Requirements Engineering', 'activity': 'Lecture', 'assessment': 'Assignment 2', 'syllabus_id': syllabus.id},
    ]
    for plan in plans_to_add:
        if plan['week'] not in existing_weeks:
            item = teaching_plan_service.create_teaching_plan(plan)
            print(f"‚úÖ  Added Teaching Plan Week: {item.week}")
        else:
            print(f"‚úÖ  Teaching Plan exists for week: {plan['week']}")

    # Assessments: Schemes, Components, Rubrics, CLO mappings
    assessment_scheme_service = container.assessment_scheme_service()
    assessment_component_service = container.assessment_component_service()
    rubric_service = container.rubric_service()
    assessment_clo_service = container.assessment_clo_service()

    existing_schemes = {s.name for s in assessment_scheme_service.list_schemes_for_syllabus(syllabus.id)}

    # Example scheme: Midterm
    if 'Midterm' not in existing_schemes:
        scheme = assessment_scheme_service.create_scheme({'syllabus_id': syllabus.id, 'name': 'Midterm', 'weight': 30.0})
        print(f"‚úÖ  Created Assessment Scheme: {scheme.name}")
        comp = assessment_component_service.create_component({'scheme_id': scheme.id, 'name': 'Midterm Exam', 'weight': 30.0})
        print(f"‚úÖ  Created Assessment Component: {comp.name}")
        rubric = rubric_service.create_rubric({'component_id': comp.id, 'criteria': 'Comprehensive exam', 'max_score': 100})
        print(f"‚úÖ  Created Rubric for component: {rubric.criteria}")
        # Map to CLO1 if exists
        clo1 = None
        for c in syllabus_clo_service.get_by_syllabus(syllabus.id):
            if c.code == 'CLO1':
                clo1 = c
                break
        if clo1:
            assessment_clo_service.add_mapping(comp.id, clo1.id)
            print(f"‚úÖ  Mapped component {comp.name} to CLO {clo1.code}")
    else:
        print('‚úÖ  Midterm scheme exists')

    print('\n‚úÖ  Seeding complete!')


if __name__ == '__main__':
    seed()
</file>

<file path="scripts/test_login.js">
const axios = require('axios');

axios.post('http://localhost:9999/auth/login', { username: 'gv1', password: '123456' })
  .then(res => {
    console.log('status', res.status);
    console.log('data', res.data);
  })
  .catch(err => {
    if (err.response) {
      console.error('status', err.response.status);
      console.error(err.response.data);
    } else {
      console.error('error', err.message);
    }
    process.exit(1);
  });
</file>

<file path="scripts/test_login.py">
import requests

r = requests.post('http://localhost:9999/auth/login', json={'username':'gv1','password':'123456'})
print('status:', r.status_code)
print('headers:', r.headers)
print('body:', r.text)
</file>

<file path="seed_all_data.py">
import sys
import os
from werkzeug.security import generate_password_hash
from datetime import datetime, date
import json

# --- C·∫§U H√åNH ƒê∆Ø·ªúNG D·∫™N IMPORT ---
current_dir = os.path.dirname(os.path.abspath(__file__))
src_path = os.path.join(current_dir, 'src')
if src_path not in sys.path:
    sys.path.insert(0, src_path)

# --- IMPORT MODULES ---
try:
    from infrastructure.databases.mssql import session, engine, Base
    from infrastructure.models import (
        User, Role, UserRole, Faculty, Department, Program, ProgramOutcome,
        Subject, AcademicYear, Syllabus, SyllabusClo, SyllabusMaterial,
        TeachingPlan, AssessmentScheme, AssessmentComponent, Rubric
    )
    # Import th√™m b·∫£ng ph·ª• n·∫øu c·∫ßn
    from infrastructure.models.workflow_state_model import WorkflowState
except ImportError as e:
    print(f"‚ùå L·ªói Import: {e}")
    sys.exit(1)

# ----------------------------------------

def hash_password(password: str) -> str:
    """Hash password using werkzeug.generate_password_hash"""
    return generate_password_hash(password)

def seed_all():
    print("üå± B·∫Øt ƒë·∫ßu n·∫°p d·ªØ li·ªáu m·∫´u (Seeding)...")
    
    # 1. T·∫°o Tables
    try:
        Base.metadata.create_all(bind=engine)
    except Exception as e:
        print(f"‚ö†Ô∏è C·∫£nh b√°o t·∫°o b·∫£ng: {e}")

    try:
        # --- 2. ROLES ---
        print("... Seeding Roles")
        roles_data = {
            "Admin": "Qu·∫£n tr·ªã h·ªá th·ªëng",
            "Lecturer": "Gi·∫£ng vi√™n",
            "Head of Dept": "Tr∆∞·ªüng b·ªô m√¥n",
            "Academic Affairs": "Ph√≤ng ƒë√†o t·∫°o",
            "Student": "Sinh vi√™n"
        }
        role_objs = {}
        for name, desc in roles_data.items():
            role = session.query(Role).filter_by(name=name).first()
            if not role:
                role = Role(name=name, description=desc)
                session.add(role)
            role_objs[name] = role
        session.flush()

        # --- 3. FACULTY & DEPARTMENT ---
        print("... Seeding Faculty & Departments")
        faculty = session.query(Faculty).filter_by(code="CNTT").first()
        if not faculty:
            faculty = Faculty(code="CNTT", name="C√¥ng ngh·ªá th√¥ng tin")
            session.add(faculty)
            session.flush()

        depts_data = [
            {"code": "CNPM", "name": "K·ªπ thu·∫≠t ph·∫ßn m·ªÅm"},
            {"code": "KHMT", "name": "Khoa h·ªçc m√°y t√≠nh"},
            {"code": "HTTT", "name": "H·ªá th·ªëng th√¥ng tin"}
        ]
        dept_objs = {}
        for d in depts_data:
            dept = session.query(Department).filter_by(code=d["code"]).first()
            if not dept:
                dept = Department(code=d["code"], name=d["name"], faculty_id=faculty.id)
                session.add(dept)
            dept_objs[d["code"]] = dept
        session.flush()

        # --- 4. USERS ---
        print("... Seeding Users")
        users_data = [
            {"u": "admin", "n": "Qu·∫£n Tr·ªã Vi√™n", "r": "Admin", "d": None},
            {"u": "gv1", "n": "Nguy·ªÖn VƒÉn A", "r": "Lecturer", "d": "CNPM"},
            {"u": "gv2", "n": "Tr·∫ßn Th·ªã B", "r": "Lecturer", "d": "KHMT"},
            {"u": "hod1", "n": "TS. L√™ VƒÉn C", "r": "Head of Dept", "d": "CNPM"},
            {"u": "aa1", "n": "Ph√≤ng ƒê√†o T·∫°o", "r": "Academic Affairs", "d": None},
            {"u": "sv1", "n": "Sinh Vi√™n Test", "r": "Student", "d": "CNPM"},
        ]
        
        user_objs = {}
        default_pass = hash_password("123456")

        for u in users_data:
            user = session.query(User).filter_by(username=u["u"]).first()
            dept_id = dept_objs[u["d"]].id if u["d"] else None
            if not user:
                user = User(
                    username=u["u"],
                    email=f"{u['u']}@ut.edu.vn",
                    full_name=u["n"],
                    password_hash=default_pass,
                    department_id=dept_id,
                    is_active=True
                )
                session.add(user)
                session.flush()

                # G√°n Role
                if u["r"] in role_objs:
                    user_role = UserRole(user_id=user.id, role_id=role_objs[u["r"]].id)
                    session.add(user_role)
            else:
                # Ensure seeded test users have werkzeug-hashed passwords (migrate old bcrypt hashes)
                user.password_hash = default_pass
                # Ensure role assignment exists
                existing_role = session.query(UserRole).filter_by(user_id=user.id).first()
                if not existing_role and u["r"] in role_objs:
                    user_role = UserRole(user_id=user.id, role_id=role_objs[u["r"]].id)
                    session.add(user_role)

            user_objs[u["u"]] = user
        session.flush()

        # --- 5. PROGRAMS ---
        print("... Seeding Programs")
        prog = session.query(Program).filter_by(name="K·ªπ s∆∞ Ph·∫ßn m·ªÅm").first()
        if not prog:
            prog = Program(department_id=dept_objs["CNPM"].id, name="K·ªπ s∆∞ Ph·∫ßn m·ªÅm", total_credits=150)
            session.add(prog)
            session.flush()
            
            plos = [
                ("PLO1", "√Åp d·ª•ng ki·∫øn th·ª©c to√°n h·ªçc"),
                ("PLO2", "Ph√¢n t√≠ch v√† thi·∫øt k·∫ø h·ªá th·ªëng"),
                ("PLO3", "K·ªπ nƒÉng l·∫≠p tr√¨nh chuy√™n s√¢u")
            ]
            for code, desc in plos:
                session.add(ProgramOutcome(program_id=prog.id, code=code, description=desc))
        session.flush()

        # --- 6. ACADEMIC YEAR ---
        print("... Seeding Academic Years")
        ay = session.query(AcademicYear).filter_by(code="2025-2026").first()
        if not ay:
            ay = AcademicYear(
                code="2025-2026", 
                start_date=date(2025, 9, 1), 
                end_date=date(2026, 6, 30)
            )
            session.add(ay)
        session.flush()

        # --- 7. SUBJECTS ---
        print("... Seeding Subjects")
        # Ch√∫ √Ω: C·∫•u tr√∫c Subject ƒë√£ thay ƒë·ªïi (name_vi, name_en, credit_theory...)
        subjects_data = [
            {"code": "IT001", "vi": "Nh·∫≠p m√¥n L·∫≠p tr√¨nh", "en": "Intro to Programming", "cr": 3},
            {"code": "SE101", "vi": "C√¥ng ngh·ªá Ph·∫ßn m·ªÅm", "en": "Software Engineering", "cr": 4},
            {"code": "WEB01", "vi": "L·∫≠p tr√¨nh Web", "en": "Web Development", "cr": 3},
        ]
        subj_objs = {}
        for s in subjects_data:
            subj = session.query(Subject).filter_by(code=s["code"]).first()
            if not subj:
                subj = Subject(
                    department_id=dept_objs["CNPM"].id,
                    code=s["code"],
                    name_vi=s["vi"],
                    name_en=s["en"],
                    credits=s["cr"],
                    credit_theory=s["cr"],     # M·∫∑c ƒë·ªãnh l√Ω thuy·∫øt = t·ªïng t√≠n ch·ªâ (v√≠ d·ª• ƒë∆°n gi·∫£n)
                    credit_practice=0,
                    credit_self_study=s["cr"] * 2
                )
                session.add(subj)
            subj_objs[s["code"]] = subj
        session.flush()

        # --- 8. SYLLABUS ---
        print("... Seeding Syllabus")
        
        if "WEB01" in subj_objs and "gv1" in user_objs:
            web_subj = subj_objs["WEB01"]
            lecturer = user_objs["gv1"]
            
            existing_syl = session.query(Syllabus).filter_by(subject_id=web_subj.id).first()
            if not existing_syl:
                # FIX L·ªñI: Kh√¥ng truy·ªÅn 'description' v√¨ model kh√¥ng c√≥ c·ªôt n√†y
                syl = Syllabus(
                    subject_id=web_subj.id,
                    program_id=prog.id,
                    academic_year_id=ay.id,
                    lecturer_id=lecturer.id,
                    status="Approved",
                    version="1.0",
                    # L∆∞u JSON v√†o c·ªôt Text
                    time_allocation=json.dumps({"theory": 30, "practice": 15, "self_study": 90}), 
                    prerequisites="Tin h·ªçc ƒë·∫°i c∆∞∆°ng",
                    publish_date=datetime.now(),
                    is_active=True
                )
                session.add(syl)
                session.flush()

                # 8.1 CLOs (SyllabusClo C√ì c·ªôt description)
                clos = [
                    SyllabusClo(syllabus_id=syl.id, code="CLO1", description="Hi·ªÉu ki·∫øn th·ª©c c∆° b·∫£n v·ªÅ Web"),
                    SyllabusClo(syllabus_id=syl.id, code="CLO2", description="V·∫≠n d·ª•ng ReactJS x√¢y d·ª±ng UI"),
                    SyllabusClo(syllabus_id=syl.id, code="CLO3", description="Tri·ªÉn khai ·ª©ng d·ª•ng l√™n Vercel")
                ]
                session.add_all(clos)
                session.flush()

                # 8.2 Teaching Plan
                plans = [
                    TeachingPlan(syllabus_id=syl.id, week=1, topic="T·ªïng quan Web", activity="Gi·∫£ng l√Ω thuy·∫øt", assessment="ƒêi·ªÉm danh"),
                    TeachingPlan(syllabus_id=syl.id, week=2, topic="HTML & CSS", activity="Code demo", assessment="B√†i t·∫≠p v·ªÅ nh√†"),
                ]
                session.add_all(plans)

                # 8.3 Materials
                materials = [
                    SyllabusMaterial(syllabus_id=syl.id, type="Main", title="Gi√°o tr√¨nh L·∫≠p tr√¨nh Web", author="Nguy·ªÖn VƒÉn A"),
                ]
                session.add_all(materials)

                # 8.4 Assessment Scheme
                scheme = AssessmentScheme(syllabus_id=syl.id, name="ƒê√°nh gi√° qu√° tr√¨nh", weight=50)
                session.add(scheme)
                session.flush()

                comp = AssessmentComponent(scheme_id=scheme.id, name="ƒê·ªì √°n gi·ªØa k·ª≥", weight=50)
                session.add(comp)
                session.flush()
                
                # Rubric
                rubric = Rubric(
                    component_id=comp.id, 
                    criteria="Giao di·ªán ƒë·∫πp", 
                    max_score=10, 
                    description_level_pass="ƒê·∫πp", 
                    description_level_fail="X·∫•u"
                )
                session.add(rubric)

        session.commit()
        print("‚úÖ ƒê√£ n·∫°p d·ªØ li·ªáu th√†nh c√¥ng! (Seed Completed)")

    except Exception as e:
        session.rollback()
        print(f"‚ùå C√≥ l·ªói x·∫£y ra: {e}")
        import traceback
        traceback.print_exc()
    finally:
        session.close()

if __name__ == "__main__":
    seed_all()
</file>

<file path="src/api/controllers/academic_year_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.academic_year_service import AcademicYearService
from api.schemas.academic_year_schema import AcademicYearSchema

academic_year_bp = Blueprint('academic_year', __name__, url_prefix='/academic-years')

schema = AcademicYearSchema()

@academic_year_bp.route('/', methods=['GET'])
@inject
def list_academic_years(academic_year_service: AcademicYearService = Provide[Container.academic_year_service]):
    """Get all academic years
    ---
    get:
      summary: Get all academic years
      tags:
        - AcademicYears
      responses:
        200:
          description: List of academic years
    """
    items = academic_year_service.list_academic_years()
    return jsonify(schema.dump(items, many=True)), 200

@academic_year_bp.route('/', methods=['POST'])
@inject
def create_academic_year(academic_year_service: AcademicYearService = Provide[Container.academic_year_service]):
    """Create a new academic year
    ---
    post:
      summary: Create an academic year
      tags:
        - AcademicYears
      requestBody:
        required: true
      responses:
        201:
          description: Created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    ay = academic_year_service.create_academic_year(data)
    return jsonify(schema.dump(ay)), 201

@academic_year_bp.route('/<int:id>', methods=['PUT'])
@inject
def update_academic_year(id: int, academic_year_service: AcademicYearService = Provide[Container.academic_year_service]):
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    ay = academic_year_service.update_academic_year(id, data)
    if not ay:
        return jsonify({'message': 'AcademicYear not found'}), 404
    return jsonify(schema.dump(ay)), 200

@academic_year_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_academic_year(id: int, academic_year_service: AcademicYearService = Provide[Container.academic_year_service]):
    ok = academic_year_service.delete_academic_year(id)
    if not ok:
        return jsonify({'message': 'AcademicYear not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/ai_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.ai_service import AiService

ai_bp = Blueprint('ai', __name__, url_prefix='/ai')

@ai_bp.route('/generate', methods=['POST'])
@inject
def generate(ai_service: AiService = Provide[Container.ai_service]):
    data = request.get_json() or {}
    subject_name = data.get('subject_name')
    if not subject_name:
        return jsonify({'message': 'subject_name is required'}), 400

    res = ai_service.generate(subject_name)
    if isinstance(res, dict) and res.get('error'):
        return jsonify({'message': res.get('error')}), 500

    return jsonify(res), 200
</file>

<file path="src/api/controllers/assessment_clo_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.assessment_clo_service import AssessmentCloService
from api.schemas.assessment_clo_mapping_schema import AssessmentCloMappingSchema

assessment_clo_bp = Blueprint('assessment_clo_map', __name__, url_prefix='/assessment-clos')

schema = AssessmentCloMappingSchema()

@assessment_clo_bp.route('/component/<int:component_id>', methods=['GET'])
@inject
def list_clos(component_id: int, service: AssessmentCloService = Provide[Container.assessment_clo_service]):
    """
    List CLOs mapped to a component
    ---
    tags:
      - Assessments
    parameters:
      - name: component_id
        in: path
        required: true
        schema:
          type: integer
    responses:
      200:
        description: List of CLOs (id, code, description)
        content:
          application/json:
            schema:
              type: array
              items:
                type: object
                properties:
                  id:
                    type: integer
                  code:
                    type: string
                  description:
                    type: string
    """
    items = service.get_clos_for_component(component_id)
    return jsonify([{'id': c.id, 'code': c.code, 'description': c.description} for c in items]), 200

@assessment_clo_bp.route('/', methods=['POST'])
@inject
def add_mapping(service: AssessmentCloService = Provide[Container.assessment_clo_service]):
    """
    Map a CLO to an assessment component
    ---
    tags:
      - Assessments
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AssessmentCloMapping'
    responses:
      201:
        description: Mapping created
      400:
        description: Validation or integrity error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        mapping = service.add_mapping(data['assessment_component_id'], data['syllabus_clo_id'])
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify({'assessment_component_id': mapping.assessment_component_id, 'syllabus_clo_id': mapping.syllabus_clo_id}), 201

@assessment_clo_bp.route('/', methods=['DELETE'])
@inject
def remove_mapping(service: AssessmentCloService = Provide[Container.assessment_clo_service]):
    """
    Remove a mapping between component and CLO
    ---
    tags:
      - Assessments
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AssessmentCloMapping'
    responses:
      204:
        description: Mapping removed
      400:
        description: Bad request
      404:
        description: Mapping not found
    """
    data = request.get_json() or {}
    if not data:
        return jsonify({'error': 'Provide JSON body with assessment_component_id and syllabus_clo_id'}), 400
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    ok = service.remove_mapping(data['assessment_component_id'], data['syllabus_clo_id'])
    if not ok:
        return jsonify({'message': 'Mapping not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/assessment_component_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.assessment_component_service import AssessmentComponentService
from api.schemas.assessment_component_schema import AssessmentComponentSchema

assessment_component_bp = Blueprint('assessment_component', __name__, url_prefix='/assessment-components')

schema = AssessmentComponentSchema()

@assessment_component_bp.route('/', methods=['POST'])
@inject
def create_component(service: AssessmentComponentService = Provide[Container.assessment_component_service]):
    """
    Create an assessment component
    ---
    tags:
      - Assessments
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AssessmentComponent'
    responses:
      201:
        description: Component created
      400:
        description: Validation or creation error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = service.create_component(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(item)), 201

@assessment_component_bp.route('/<int:id>', methods=['PUT'])
@inject
def update_component(id: int, service: AssessmentComponentService = Provide[Container.assessment_component_service]):
    """
    Update an assessment component
    ---
    tags:
      - Assessments
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AssessmentComponent'
    responses:
      200:
        description: Component updated
      400:
        description: Validation error
      404:
        description: Component not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    item = service.update_component(id, data)
    if not item:
        return jsonify({'message': 'Component not found'}), 404
    return jsonify(schema.dump(item)), 200

@assessment_component_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_component(id: int, service: AssessmentComponentService = Provide[Container.assessment_component_service]):
    """
    Delete an assessment component
    ---
    tags:
      - Assessments
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    responses:
      204:
        description: Deleted
      404:
        description: Component not found
    """
    ok = service.delete_component(id)
    if not ok:
        return jsonify({'message': 'Component not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/assessment_scheme_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.assessment_scheme_service import AssessmentSchemeService
from api.schemas.assessment_scheme_schema import AssessmentSchemeSchema

assessment_scheme_bp = Blueprint('assessment_scheme', __name__, url_prefix='/assessment-schemes')

schema = AssessmentSchemeSchema()

@assessment_scheme_bp.route('/syllabus/<int:syllabus_id>', methods=['GET'])
@inject
def list_schemes(syllabus_id: int, service: AssessmentSchemeService = Provide[Container.assessment_scheme_service]):
    """
    List assessment schemes for a syllabus
    ---
    tags:
      - Assessments
    parameters:
      - name: syllabus_id
        in: path
        required: true
        schema:
          type: integer
    responses:
      200:
        description: List of assessment schemes
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/AssessmentScheme'
    """
    items = service.list_schemes_for_syllabus(syllabus_id)
    return jsonify(schema.dump(items, many=True)), 200

@assessment_scheme_bp.route('/', methods=['POST'])
@inject
def create_scheme(service: AssessmentSchemeService = Provide[Container.assessment_scheme_service]):
    """
    Create an assessment scheme
    ---
    tags:
      - Assessments
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AssessmentScheme'
    responses:
      201:
        description: Scheme created
      400:
        description: Validation or creation error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = service.create_scheme(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(item)), 201

@assessment_scheme_bp.route('/<int:id>', methods=['PUT'])
@inject
def update_scheme(id: int, service: AssessmentSchemeService = Provide[Container.assessment_scheme_service]):
    """
    Update an assessment scheme
    ---
    tags:
      - Assessments
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AssessmentScheme'
    responses:
      200:
        description: Scheme updated
      400:
        description: Validation error
      404:
        description: Scheme not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    item = service.update_scheme(id, data)
    if not item:
        return jsonify({'message': 'Scheme not found'}), 404
    return jsonify(schema.dump(item)), 200

@assessment_scheme_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_scheme(id: int, service: AssessmentSchemeService = Provide[Container.assessment_scheme_service]):
    """
    Delete an assessment scheme
    ---
    tags:
      - Assessments
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    responses:
      204:
        description: Deleted
      404:
        description: Scheme not found
    """
    ok = service.delete_scheme(id)
    if not ok:
        return jsonify({'message': 'Scheme not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/auth_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.user_service import UserService
from config import Config
import jwt
from datetime import datetime, timedelta

auth_bp = Blueprint('auth', __name__, url_prefix='/auth')

@auth_bp.route('/login', methods=['POST'])
@inject
def login(user_service: UserService = Provide[Container.user_service]):
    """
    Login and obtain a token
    ---
    tags:
      - Auth
    requestBody:
      required: true
      content:
        application/json:
          schema:
            type: object
            properties:
              username:
                type: string
              password:
                type: string
            required:
              - username
              - password
    responses:
      200:
        description: Login successful, returns token and user information
      400:
        description: Missing username or password
      401:
        description: Invalid credentials
    """
    data = request.get_json() or {}
    username = data.get('username')
    password = data.get('password')
    if not username or not password:
        return jsonify({'message': 'username and password are required'}), 400
    # Authenticate using service (verifies password hash)
    user = user_service.authenticate(username, password)
    if not user:
        return jsonify({'message': 'Invalid credentials'}), 401

    # Get role name if available
    role_name = None
    try:
        if user.roles and len(user.roles) > 0 and getattr(user.roles[0], 'role', None):
            role_name = user.roles[0].role.name
    except Exception:
        role_name = None

    # Create JWT
    secret = Config.SECRET_KEY
    payload = {
        'sub': username,
        'user_id': user.id,
        'role': role_name,
        'exp': datetime.utcnow() + timedelta(hours=6)
    }
    token = jwt.encode(payload, secret, algorithm='HS256')

    return jsonify({'token': token, 'user_id': user.id, 'role': role_name}), 200
</file>

<file path="src/api/controllers/clo_plo_mapping_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.clo_plo_mapping_service import CloPloMappingService
from api.schemas.clo_plo_mapping_schema import CloPloMappingSchema

clo_plo_mapping_bp = Blueprint('clo_plo_mapping', __name__, url_prefix='/clo-plo-mappings')
schema = CloPloMappingSchema()

@clo_plo_mapping_bp.route('/', methods=['POST'])
@inject
def create_mapping(service: CloPloMappingService = Provide[Container.clo_plo_mapping_service]):
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = service.create_mapping(data)
        return jsonify(schema.dump(item)), 201
    except ValueError as e:
        return jsonify({'error': str(e)}), 400

@clo_plo_mapping_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_mapping(id: int, service: CloPloMappingService = Provide[Container.clo_plo_mapping_service]):
    ok = service.delete_mapping(id)
    if not ok:
        return jsonify({'message': 'Mapping not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/dashboard_controller.py">
from flask import Blueprint, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.syllabus_service import SyllabusService
from services.user_service import UserService

dashboard_bp = Blueprint('dashboard', __name__, url_prefix='/stats')

@dashboard_bp.route('/', methods=['GET'])
@inject
def get_stats(syllabus_service: SyllabusService = Provide[Container.syllabus_service], user_service: UserService = Provide[Container.user_service]):
    syllabuses = syllabus_service.list_syllabuses() or []
    users = user_service.list_users() or []

    total_syllabuses = len(syllabuses)
    total_users = len(users)

    # Group by status
    stats_by_status = {
        'Approved': 0,
        'Pending': 0,
        'Draft': 0,
        'Returned': 0
    }
    for s in syllabuses:
        status = getattr(s, 'status', None) or getattr(s, 'state', None) or 'Draft'
        # Normalize
        if status.upper() in ('APPROVED',):
            stats_by_status['Approved'] += 1
        elif 'PENDING' in status.upper():
            stats_by_status['Pending'] += 1
        elif status.upper() in ('RETURNED', 'REJECTED'):
            stats_by_status['Returned'] += 1
        else:
            stats_by_status['Draft'] += 1

    return jsonify({
        'total_syllabuses': total_syllabuses,
        'total_users': total_users,
        'by_status': stats_by_status
    }), 200
</file>

<file path="src/api/controllers/department_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.department_service import DepartmentService
from api.schemas.department_schema import DepartmentSchema

department_bp = Blueprint('department', __name__, url_prefix='/departments')

schema = DepartmentSchema()

@department_bp.route('/', methods=['GET'])
@inject
def list_departments(department_service: DepartmentService = Provide[Container.department_service]):
    """Get all departments
    ---
    get:
      summary: Get all departments
      tags:
        - Departments
      responses:
        200:
          description: List of departments
    """
    departments = department_service.list_departments()
    return jsonify(schema.dump(departments, many=True)), 200

@department_bp.route('/<int:id>', methods=['GET'])
@inject
def get_department(id: int, department_service: DepartmentService = Provide[Container.department_service]):
    """Get department by id
    ---
    get:
      summary: Get department by ID
      tags:
        - Departments
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: Department object
        404:
          description: Not found
    """
    department = department_service.get_department(id)
    if not department:
        return jsonify({'message': 'Department not found'}), 404
    return jsonify(schema.dump(department)), 200

@department_bp.route('/', methods=['POST'])
@inject
def create_department(department_service: DepartmentService = Provide[Container.department_service]):
    """Create a new department
    ---
    post:
      summary: Create a new department
      tags:
        - Departments
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Department'
      responses:
        201:
          description: Department created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    department = department_service.create_department(data)
    return jsonify(schema.dump(department)), 201

@department_bp.route('/<int:id>', methods=['PUT'])
@inject
def update_department(id: int, department_service: DepartmentService = Provide[Container.department_service]):
    """Update an existing department
    ---
    put:
      summary: Update department
      tags:
        - Departments
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Department'
      responses:
        200:
          description: Department updated
        400:
          description: Invalid input
        404:
          description: Department not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    department = department_service.update_department(id, data)
    if not department:
        return jsonify({'message': 'Department not found'}), 404
    return jsonify(schema.dump(department)), 200

@department_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_department(id: int, department_service: DepartmentService = Provide[Container.department_service]):
    """Delete department
    ---
    delete:
      summary: Delete department
      tags:
        - Departments
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        204:
          description: Deleted
        404:
          description: Department not found
    """
    ok = department_service.delete_department(id)
    if not ok:
        return jsonify({'message': 'Department not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/faculty_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.faculty_service import FacultyService
from api.schemas.faculty_schema import FacultySchema

faculty_bp = Blueprint('faculty', __name__, url_prefix='/faculties')

schema = FacultySchema()

@faculty_bp.route('/', methods=['GET'])
@inject
def list_faculties(faculty_service: FacultyService = Provide[Container.faculty_service]):
    """Get all faculties
    ---
    get:
      summary: Get all faculties
      tags:
        - Faculties
      responses:
        200:
          description: List of faculties
    """
    faculties = faculty_service.list_faculties()
    return jsonify(schema.dump(faculties, many=True)), 200

@faculty_bp.route('/<int:id>', methods=['GET'])
@inject
def get_faculty(id: int, faculty_service: FacultyService = Provide[Container.faculty_service]):
    """Get faculty by id
    ---
    get:
      summary: Get faculty by ID
      tags:
        - Faculties
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: Faculty object
        404:
          description: Not found
    """
    faculty = faculty_service.get_faculty(id)
    if not faculty:
        return jsonify({'message': 'Faculty not found'}), 404
    return jsonify(schema.dump(faculty)), 200

@faculty_bp.route('/', methods=['POST'])
@inject
def create_faculty(faculty_service: FacultyService = Provide[Container.faculty_service]):
    """Create a new faculty
    ---
    post:
      summary: Create a new faculty
      tags:
        - Faculties
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Faculty'
      responses:
        201:
          description: Faculty created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    faculty = faculty_service.create_faculty(data)
    return jsonify(schema.dump(faculty)), 201

@faculty_bp.route('/<int:id>', methods=['PUT'])
@inject
def update_faculty(id: int, faculty_service: FacultyService = Provide[Container.faculty_service]):
    """Update an existing faculty
    ---
    put:
      summary: Update faculty
      tags:
        - Faculties
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Faculty'
      responses:
        200:
          description: Faculty updated
        400:
          description: Invalid input
        404:
          description: Faculty not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    faculty = faculty_service.update_faculty(id, data)
    if not faculty:
        return jsonify({'message': 'Faculty not found'}), 404
    return jsonify(schema.dump(faculty)), 200

@faculty_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_faculty(id: int, faculty_service: FacultyService = Provide[Container.faculty_service]):
    """Delete faculty
    ---
    delete:
      summary: Delete faculty
      tags:
        - Faculties
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        204:
          description: Deleted
        404:
          description: Faculty not found
    """
    ok = faculty_service.delete_faculty(id)
    if not ok:
        return jsonify({'message': 'Faculty not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/file_controller.py">
from flask import Blueprint, request, jsonify, send_file
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.file_service import FileService
from api.schemas.file_schema import FileSchema
import os

file_bp = Blueprint('file', __name__, url_prefix='/files')
schema = FileSchema()

@file_bp.route('/upload', methods=['POST'])
@inject
def upload_file(service: FileService = Provide[Container.file_service]):
    if 'file' not in request.files:
        return jsonify({'error': 'No file part'}), 400
    file = request.files['file']
    # Demo: assume user_id=1 if no auth (In production, get from token)
    user_id = request.form.get('user_id', 1) 
    try:
        record = service.upload_file(file, int(user_id))
        return jsonify(schema.dump(record)), 201
    except ValueError as e:
        return jsonify({'error': str(e)}), 400

@file_bp.route('/<int:id>', methods=['GET'])
@inject
def download_file(id: int, service: FileService = Provide[Container.file_service]):
    record = service.get_file(id)
    if not record:
        return jsonify({'message': 'File not found'}), 404
    try:
        return send_file(os.path.abspath(record.file_path), as_attachment=True, download_name=record.file_name)
    except Exception:
        return jsonify({'message': 'File not found on disk'}), 404
</file>

<file path="src/api/controllers/notification_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.notification_service import NotificationService
from api.schemas.notification_schema import NotificationSchema
from api.middleware import token_required

notification_bp = Blueprint('notification', __name__, url_prefix='/notifications')
schema = NotificationSchema()

@notification_bp.route('/', methods=['GET'])
@inject
@token_required
def get_my_notifications(service: NotificationService = Provide[Container.notification_service]):
    # In production, get user_id from token. For demo, we might read header or assume user_id=1 if not parsed.
    user_id = getattr(request, 'user', {}).get('user_id')
    if not user_id:
         return jsonify({'message': 'User context missing'}), 401
    unread = request.args.get('unread', 'false').lower() == 'true'
    items = service.get_user_notifications(user_id, unread_only=unread)
    return jsonify(schema.dump(items, many=True)), 200

@notification_bp.route('/<int:id>/read', methods=['PUT'])
@inject
@token_required
def mark_read(id: int, service: NotificationService = Provide[Container.notification_service]):
    ok = service.mark_read(id)
    if not ok:
        return jsonify({'message': 'Notification not found'}), 404
    return jsonify({'message': 'Marked as read'}), 200
</file>

<file path="src/api/controllers/program_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.program_service import ProgramService
from api.schemas.program_schema import ProgramSchema

program_bp = Blueprint('program', __name__, url_prefix='/programs')

schema = ProgramSchema()

@program_bp.route('/', methods=['GET'])
@inject
def list_programs(program_service: ProgramService = Provide[Container.program_service]):
    """Get all programs
    ---
    get:
      summary: Get all programs
      tags:
        - Programs
      responses:
        200:
          description: List of programs
    """
    items = program_service.list_programs()
    return jsonify(schema.dump(items, many=True)), 200

@program_bp.route('/', methods=['POST'])
@inject
def create_program(program_service: ProgramService = Provide[Container.program_service]):
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    p = program_service.create_program(data)
    return jsonify(schema.dump(p)), 201

@program_bp.route('/<int:id>', methods=['PUT'])
@inject
def update_program(id: int, program_service: ProgramService = Provide[Container.program_service]):
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    p = program_service.update_program(id, data)
    if not p:
        return jsonify({'message': 'Program not found'}), 404
    return jsonify(schema.dump(p)), 200

@program_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_program(id: int, program_service: ProgramService = Provide[Container.program_service]):
    ok = program_service.delete_program(id)
    if not ok:
        return jsonify({'message': 'Program not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/program_outcome_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.program_outcome_service import ProgramOutcomeService
from api.schemas.program_outcome_schema import ProgramOutcomeSchema

program_outcome_bp = Blueprint('program_outcome', __name__, url_prefix='/program-outcomes')
schema = ProgramOutcomeSchema()

@program_outcome_bp.route('/program/<int:program_id>', methods=['GET'])
@inject
def list_plos(program_id: int, service: ProgramOutcomeService = Provide[Container.program_outcome_service]):
    items = service.list_by_program(program_id)
    return jsonify(schema.dump(items, many=True)), 200

@program_outcome_bp.route('/', methods=['POST'])
@inject
def create_plo(service: ProgramOutcomeService = Provide[Container.program_outcome_service]):
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = service.create_plo(data)
        return jsonify(schema.dump(item)), 201
    except ValueError as e:
        return jsonify({'error': str(e)}), 400

@program_outcome_bp.route('/<int:id>', methods=['PUT'])
@inject
def update_plo(id: int, service: ProgramOutcomeService = Provide[Container.program_outcome_service]):
    data = request.get_json() or {}
    item = service.update_plo(id, data)
    if not item:
        return jsonify({'message': 'PLO not found'}), 404
    return jsonify(schema.dump(item)), 200

@program_outcome_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_plo(id: int, service: ProgramOutcomeService = Provide[Container.program_outcome_service]):
    ok = service.delete_plo(id)
    if not ok:
        return jsonify({'message': 'PLO not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/role_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.role_service import RoleService
from api.schemas.role_schema import RoleSchema

role_bp = Blueprint('role', __name__, url_prefix='/roles')

schema = RoleSchema()

@role_bp.route('/', methods=['GET'])
@inject
def list_roles(role_service: RoleService = Provide[Container.role_service]):
    """Get all roles
    ---
    get:
      summary: Get all roles
      tags:
        - Roles
      responses:
        200:
          description: List of roles
    """
    roles = role_service.list_roles()
    return jsonify(schema.dump(roles, many=True)), 200

@role_bp.route('/', methods=['POST'])
@inject
def create_role(role_service: RoleService = Provide[Container.role_service]):
    """Create a new role
    ---
    post:
      summary: Create a new role
      tags:
        - Roles
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Role'
      responses:
        201:
          description: Role created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    role = role_service.create_role(data)
    return jsonify(schema.dump(role)), 201
</file>

<file path="src/api/controllers/rubric_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.rubric_service import RubricService
from api.schemas.rubric_schema import RubricSchema

rubric_bp = Blueprint('rubric', __name__, url_prefix='/rubrics')

schema = RubricSchema()

@rubric_bp.route('/component/<int:component_id>', methods=['GET'])
@inject
def list_rubrics(component_id: int, rubric_service: RubricService = Provide[Container.rubric_service]):
    """
    List rubrics for a component
    ---
    tags:
      - Rubrics
    parameters:
      - name: component_id
        in: path
        required: true
        schema:
          type: integer
    responses:
      200:
        description: List of rubrics
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/Rubric'
    """
    items = rubric_service.list_rubrics_for_component(component_id)
    return jsonify(schema.dump(items, many=True)), 200

@rubric_bp.route('/', methods=['POST'])
@inject
def create_rubric(rubric_service: RubricService = Provide[Container.rubric_service]):
    """
    Create a rubric
    ---
    tags:
      - Rubrics
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Rubric'
    responses:
      201:
        description: Rubric created
      400:
        description: Validation or creation error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = rubric_service.create_rubric(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(item)), 201

@rubric_bp.route('/<int:id>', methods=['PUT'])
@inject
def update_rubric(id: int, rubric_service: RubricService = Provide[Container.rubric_service]):
    """
    Update a rubric
    ---
    tags:
      - Rubrics
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Rubric'
    responses:
      200:
        description: Rubric updated
      400:
        description: Validation error
      404:
        description: Rubric not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    item = rubric_service.update_rubric(id, data)
    if not item:
        return jsonify({'message': 'Rubric not found'}), 404
    return jsonify(schema.dump(item)), 200

@rubric_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_rubric(id: int, rubric_service: RubricService = Provide[Container.rubric_service]):
    """
    Delete a rubric
    ---
    tags:
      - Rubrics
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    responses:
      204:
        description: Deleted
      404:
        description: Rubric not found
    """
    ok = rubric_service.delete_rubric(id)
    if not ok:
        return jsonify({'message': 'Rubric not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/student_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.student_service import StudentService
from api.schemas.student_schema import StudentSubscriptionSchema, StudentReportSchema

student_bp = Blueprint('student', __name__, url_prefix='/student')
sub_schema = StudentSubscriptionSchema()
rep_schema = StudentReportSchema()

@student_bp.route('/subscribe', methods=['POST'])
@inject
def subscribe(service: StudentService = Provide[Container.student_service]):
    data = request.get_json() or {}
    # In production get user_id from token
    item = service.subscribe(data['student_id'], data['subject_id'])
    return jsonify(sub_schema.dump(item)), 201

@student_bp.route('/report', methods=['POST'])
@inject
def report(service: StudentService = Provide[Container.student_service]):
    data = request.get_json() or {}
    item = service.report_syllabus(data['student_id'], data['syllabus_id'], data['content'])
    return jsonify(rep_schema.dump(item)), 201

@student_bp.route('/reports', methods=['GET'])
@inject
def list_reports(service: StudentService = Provide[Container.student_service]):
    items = service.list_reports()
    return jsonify(rep_schema.dump(items, many=True)), 200
</file>

<file path="src/api/controllers/subject_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.subject_service import SubjectService
from api.schemas.subject_schema import SubjectSchema

subject_bp = Blueprint('subject', __name__, url_prefix='/subjects')

schema = SubjectSchema()

@subject_bp.route('/', methods=['GET'])
@inject
def list_subjects(subject_service: SubjectService = Provide[Container.subject_service]):
    """Get all subjects
    ---
    get:
      summary: Get all subjects
      tags:
        - Subjects
      responses:
        200:
          description: List of subjects
    """
    subjects = subject_service.list_subjects()
    return jsonify(schema.dump(subjects, many=True)), 200

@subject_bp.route('/<int:id>', methods=['GET'])
@inject
def get_subject(id: int, subject_service: SubjectService = Provide[Container.subject_service]):
    """Get subject by id
    ---
    get:
      summary: Get subject by ID
      tags:
        - Subjects
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: Subject object
        404:
          description: Not found
    """
    subject = subject_service.get_subject(id)
    if not subject:
        return jsonify({'message': 'Subject not found'}), 404
    return jsonify(schema.dump(subject)), 200

@subject_bp.route('/', methods=['POST'])
@inject
def create_subject(subject_service: SubjectService = Provide[Container.subject_service]):
    """Create a new subject
    ---
    post:
      summary: Create a new subject
      tags:
        - Subjects
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Subject'
      responses:
        201:
          description: Subject created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    subject = subject_service.create_subject(data)
    return jsonify(schema.dump(subject)), 201

@subject_bp.route('/<int:id>', methods=['PUT'])
@inject
def update_subject(id: int, subject_service: SubjectService = Provide[Container.subject_service]):
    """Update an existing subject
    ---
    put:
      summary: Update subject
      tags:
        - Subjects
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Subject'
      responses:
        200:
          description: Subject updated
        400:
          description: Invalid input
        404:
          description: Subject not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    subject = subject_service.update_subject(id, data)
    if not subject:
        return jsonify({'message': 'Subject not found'}), 404
    return jsonify(schema.dump(subject)), 200

@subject_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_subject(id: int, subject_service: SubjectService = Provide[Container.subject_service]):
    """Delete subject
    ---
    delete:
      summary: Delete subject
      tags:
        - Subjects
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        204:
          description: Deleted
        404:
          description: Subject not found
    """
    ok = subject_service.delete_subject(id)
    if not ok:
        return jsonify({'message': 'Subject not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/subject_relationship_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.subject_relationship_service import SubjectRelationshipService
from api.schemas.subject_relationship_schema import SubjectRelationshipSchema

subject_rel_bp = Blueprint('subject_relationship', __name__, url_prefix='/subject-relationships')
schema = SubjectRelationshipSchema()

@subject_rel_bp.route('/subject/<int:subject_id>', methods=['GET'])
@inject
def list_relationships(subject_id: int, service: SubjectRelationshipService = Provide[Container.subject_relationship_service]):
    items = service.get_relationships(subject_id)
    return jsonify(schema.dump(items, many=True)), 200

@subject_rel_bp.route('/', methods=['POST'])
@inject
def create_relationship(service: SubjectRelationshipService = Provide[Container.subject_relationship_service]):
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = service.add_relationship(data)
        return jsonify(schema.dump(item)), 201
    except ValueError as e:
        return jsonify({'error': str(e)}), 400

@subject_rel_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_relationship(id: int, service: SubjectRelationshipService = Provide[Container.subject_relationship_service]):
    ok = service.remove_relationship(id)
    if not ok:
        return jsonify({'message': 'Relationship not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/syllabus_clo_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.syllabus_clo_service import SyllabusCloService
from api.schemas.syllabus_clo_schema import SyllabusCloSchema

syllabus_clo_bp = Blueprint('syllabus_clo', __name__, url_prefix='/syllabus-clos')

schema = SyllabusCloSchema()

@syllabus_clo_bp.route('/syllabus/<int:syllabus_id>', methods=['GET'])
@inject
def list_clos(syllabus_id: int, syllabus_clo_service: SyllabusCloService = Provide[Container.syllabus_clo_service]):
    """
    List CLOs for a syllabus
    ---
    tags:
      - Syllabus CLOs
    parameters:
      - name: syllabus_id
        in: path
        required: true
        schema:
          type: integer
    responses:
      200:
        description: List of CLOs
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/SyllabusClo'
    """
    items = syllabus_clo_service.get_by_syllabus(syllabus_id)
    return jsonify(schema.dump(items, many=True)), 200

@syllabus_clo_bp.route('/', methods=['POST'])
@inject
def create_clo(syllabus_clo_service: SyllabusCloService = Provide[Container.syllabus_clo_service]):
    """
    Create a new CLO for a syllabus
    ---
    tags:
      - Syllabus CLOs
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/SyllabusClo'
    responses:
      201:
        description: CLO created
      400:
        description: Validation or creation error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = syllabus_clo_service.create_clo(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(item)), 201

@syllabus_clo_bp.route('/<int:id>', methods=['PUT'])
@inject
def update_clo(id: int, syllabus_clo_service: SyllabusCloService = Provide[Container.syllabus_clo_service]):
    """
    Update an existing CLO
    ---
    tags:
      - Syllabus CLOs
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/SyllabusClo'
    responses:
      200:
        description: CLO updated
      400:
        description: Validation error
      404:
        description: CLO not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    item = syllabus_clo_service.update_clo(id, data)
    if not item:
        return jsonify({'message': 'CLO not found'}), 404
    return jsonify(schema.dump(item)), 200

@syllabus_clo_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_clo(id: int, syllabus_clo_service: SyllabusCloService = Provide[Container.syllabus_clo_service]):
    """
    Delete a CLO by id
    ---
    tags:
      - Syllabus CLOs
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    responses:
      204:
        description: Deleted
      404:
        description: CLO not found
    """
    ok = syllabus_clo_service.delete_clo(id)
    if not ok:
        return jsonify({'message': 'CLO not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/syllabus_comment_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.syllabus_comment_service import SyllabusCommentService
from api.schemas.syllabus_comment_schema import SyllabusCommentSchema

syllabus_comment_bp = Blueprint('syllabus_comment', __name__, url_prefix='/syllabus-comments')
schema = SyllabusCommentSchema()

@syllabus_comment_bp.route('/syllabus/<int:syllabus_id>', methods=['GET'])
@inject
def list_comments(syllabus_id: int, service: SyllabusCommentService = Provide[Container.syllabus_comment_service]):
    items = service.get_comments(syllabus_id)
    return jsonify(schema.dump(items, many=True)), 200

@syllabus_comment_bp.route('/', methods=['POST'])
@inject
def add_comment(service: SyllabusCommentService = Provide[Container.syllabus_comment_service]):
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = service.add_comment(data)
        return jsonify(schema.dump(item)), 201
    except ValueError as e:
        return jsonify({'error': str(e)}), 400

@syllabus_comment_bp.route('/<int:id>/resolve', methods=['PUT'])
@inject
def resolve_comment(id: int, service: SyllabusCommentService = Provide[Container.syllabus_comment_service]):
    item = service.resolve_comment(id)
    if not item:
        return jsonify({'message': 'Comment not found'}), 404
    return jsonify(schema.dump(item)), 200

@syllabus_comment_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_comment(id: int, service: SyllabusCommentService = Provide[Container.syllabus_comment_service]):
    ok = service.delete_comment(id)
    if not ok:
        return jsonify({'message': 'Comment not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/syllabus_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.syllabus_service import SyllabusService
from api.schemas.syllabus_schema import SyllabusSchema
from api.schemas.syllabus_detail_schema import SyllabusDetailSchema
from api.middleware import token_required

syllabus_bp = Blueprint('syllabus', __name__, url_prefix='/syllabuses')

schema = SyllabusSchema()
detail_schema = SyllabusDetailSchema()

@syllabus_bp.route('/', methods=['GET'])
@inject
def list_syllabuses(syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """List syllabuses
    ---
    get:
      summary: List syllabuses
      tags:
        - Syllabuses
      responses:
        200:
          description: List of syllabuses
    """
    items = syllabus_service.list_syllabuses()
    return jsonify(schema.dump(items, many=True)), 200

@syllabus_bp.route('/<int:id>', methods=['GET'])
@inject
def get_syllabus(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Get syllabus
    ---
    get:
      summary: Get syllabus by id
      tags:
        - Syllabuses
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: Syllabus object
        404:
          description: Not found
    """
    s = syllabus_service.get_syllabus(id)
    if not s:
        return jsonify({'message': 'Syllabus not found'}), 404
    return jsonify(schema.dump(s)), 200


@syllabus_bp.route('/<int:id>/details', methods=['GET'])
@inject
def get_syllabus_details(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Get full syllabus details
    ---
    get:
      summary: Get syllabus details by id
      tags:
        - Syllabuses
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: Syllabus detail object
        404:
          description: Not found
    """
    s = syllabus_service.get_syllabus_details(id)
    if not s:
        return jsonify({'message': 'Syllabus not found'}), 404
    return jsonify(detail_schema.dump(s)), 200


@syllabus_bp.route('/compare', methods=['GET'])
@inject
def compare_syllabuses(syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Compare two syllabuses by id
    ---
    get:
      summary: Compare two syllabuses
      tags:
        - Syllabuses
      parameters:
        - name: base_id
          in: query
          required: true
          schema:
            type: integer
        - name: target_id
          in: query
          required: true
          schema:
            type: integer
    responses:
      200:
        description: Differences between the two syllabuses
      404:
        description: Syllabus not found
    """
    try:
        base_id = int(request.args.get('baseId') or request.args.get('base_id'))
        target_id = int(request.args.get('targetId') or request.args.get('target_id'))
    except Exception:
        return jsonify({'message': 'base_id and target_id query parameters are required and must be integers'}), 400

    base = syllabus_service.get_syllabus_details(base_id)
    target = syllabus_service.get_syllabus_details(target_id)

    if not base or not target:
        return jsonify({'message': 'One or both syllabuses not found'}), 404

    # Fields to compare
    fields = ['subject_name_vi', 'credits', 'description', 'student_duties']
    diffs = []
    for f in fields:
        base_val = getattr(base, f, None)
        target_val = getattr(target, f, None)
        if base_val != target_val:
            diffs.append({'field': f, 'base': base_val, 'target': target_val})

    # Compare CLO counts
    base_clos = getattr(base, 'clos', []) or []
    target_clos = getattr(target, 'clos', []) or []
    if len(base_clos) != len(target_clos):
        diffs.append({'field': 'clos_count', 'base': len(base_clos), 'target': len(target_clos)})

    return jsonify({'diffs': diffs}), 200


@syllabus_bp.route('/<int:id>/submit', methods=['POST'])
@inject
def submit_syllabus(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Submit a syllabus for evaluation
    ---
    post:
      summary: Submit syllabus
      tags:
        - Syllabuses
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
      responses:
        200:
          description: Submitted syllabus
        400:
          description: Invalid action
        404:
          description: Not found
    """
    data = request.get_json() or {}
    user_id = data.get('user_id')
    if not user_id:
        return jsonify({'message': 'user_id is required'}), 400
    try:
        s = syllabus_service.submit_syllabus(id, user_id)
    except ValueError as e:
        return jsonify({'message': str(e)}), 400
    if not s:
        return jsonify({'message': 'Syllabus not found'}), 404
    return jsonify(schema.dump(s)), 200


@syllabus_bp.route('/<int:id>/evaluate', methods=['POST'])
@inject
def evaluate_syllabus(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Evaluate (approve/reject) a syllabus
    ---
    post:
      summary: Evaluate syllabus
      tags:
        - Syllabuses
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
      responses:
        200:
          description: Evaluation result
        400:
          description: Invalid action or missing comment
        404:
          description: Not found
    """
    data = request.get_json() or {}
    action = data.get('action')
    user_id = data.get('user_id')
    comment = data.get('comment')
    if not action or not user_id:
        return jsonify({'message': 'action and user_id are required'}), 400
    try:
        s = syllabus_service.evaluate_syllabus(id, user_id, action, comment)
    except ValueError as e:
        return jsonify({'message': str(e)}), 400
    if not s:
        return jsonify({'message': 'Syllabus not found'}), 404
    return jsonify(schema.dump(s)), 200


@syllabus_bp.route('/<int:id>/workflow-logs', methods=['GET'])
@inject
def get_workflow_logs(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Get workflow logs for a syllabus
    ---
    get:
      summary: Get workflow logs
      tags:
        - Syllabuses
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: List of workflow logs
        404:
          description: Not found
    """
    logs = syllabus_service.get_workflow_logs(id)
    from api.schemas.workflow_log_schema import WorkflowLogSchema
    schema_w = WorkflowLogSchema()
    return jsonify(schema_w.dump(logs, many=True)), 200

@syllabus_bp.route('/', methods=['POST'])
@inject
@token_required
def create_syllabus(syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Create a syllabus
    ---
    post:
      summary: Create syllabus
      tags:
        - Syllabuses
      requestBody:
        required: true
      responses:
        201:
          description: Created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        s = syllabus_service.create_syllabus(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(s)), 201

@syllabus_bp.route('/<int:id>', methods=['PUT'])
@inject
def update_syllabus(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    s = syllabus_service.update_syllabus(id, data)
    if not s:
        return jsonify({'message': 'Syllabus not found'}), 404
    return jsonify(schema.dump(s)), 200

@syllabus_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_syllabus(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    ok = syllabus_service.delete_syllabus(id)
    if not ok:
        return jsonify({'message': 'Syllabus not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/syllabus_material_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.syllabus_material_service import SyllabusMaterialService
from api.schemas.syllabus_material_schema import SyllabusMaterialSchema

syllabus_material_bp = Blueprint('syllabus_material', __name__, url_prefix='/syllabus-materials')

schema = SyllabusMaterialSchema()

@syllabus_material_bp.route('/syllabus/<int:syllabus_id>', methods=['GET'])
@inject
def list_materials(syllabus_id: int, syllabus_material_service: SyllabusMaterialService = Provide[Container.syllabus_material_service]):
    """
    List materials for a syllabus
    ---
    tags:
      - Syllabus Materials
    parameters:
      - name: syllabus_id
        in: path
        required: true
        schema:
          type: integer
    responses:
      200:
        description: List of materials
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/SyllabusMaterial'
    """
    items = syllabus_material_service.get_by_syllabus(syllabus_id)
    return jsonify(schema.dump(items, many=True)), 200

@syllabus_material_bp.route('/', methods=['POST'])
@inject
def create_material(syllabus_material_service: SyllabusMaterialService = Provide[Container.syllabus_material_service]):
    """
    Create a syllabus material
    ---
    tags:
      - Syllabus Materials
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/SyllabusMaterial'
    responses:
      201:
        description: Material created
      400:
        description: Validation or creation error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = syllabus_material_service.create_material(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(item)), 201

@syllabus_material_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_material(id: int, syllabus_material_service: SyllabusMaterialService = Provide[Container.syllabus_material_service]):
    """
    Delete a syllabus material
    ---
    tags:
      - Syllabus Materials
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    responses:
      204:
        description: Deleted
      404:
        description: Material not found
    """
    ok = syllabus_material_service.delete_material(id)
    if not ok:
        return jsonify({'message': 'Material not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/system_setting_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.system_setting_service import SystemSettingService
from api.schemas.system_setting_schema import SystemSettingSchema

system_setting_bp = Blueprint('system_setting', __name__, url_prefix='/system-settings')
schema = SystemSettingSchema()

@system_setting_bp.route('/', methods=['GET'])
@inject
def list_settings(service: SystemSettingService = Provide[Container.system_setting_service]):
    items = service.get_all_settings()
    return jsonify(schema.dump(items, many=True)), 200

@system_setting_bp.route('/', methods=['POST'])
@inject
def update_setting(service: SystemSettingService = Provide[Container.system_setting_service]):
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    item = service.update_setting(data['key'], data['value'], data.get('description'))
    return jsonify(schema.dump(item)), 200
</file>

<file path="src/api/controllers/teaching_plan_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.teaching_plan_service import TeachingPlanService
from api.schemas.teaching_plan_schema import TeachingPlanSchema

teaching_plan_bp = Blueprint('teaching_plan', __name__, url_prefix='/teaching-plans')

schema = TeachingPlanSchema()

@teaching_plan_bp.route('/syllabus/<int:syllabus_id>', methods=['GET'])
@inject
def list_plans(syllabus_id: int, teaching_plan_service: TeachingPlanService = Provide[Container.teaching_plan_service]):
    """
    List teaching plans for a syllabus
    ---
    tags:
      - Teaching Plans
    parameters:
      - name: syllabus_id
        in: path
        required: true
        schema:
          type: integer
    responses:
      200:
        description: List of teaching plans
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/TeachingPlan'
    """
    items = teaching_plan_service.list_plans_for_syllabus(syllabus_id)
    return jsonify(schema.dump(items, many=True)), 200

@teaching_plan_bp.route('/', methods=['POST'])
@inject
def create_plan(teaching_plan_service: TeachingPlanService = Provide[Container.teaching_plan_service]):
    """
    Create a teaching plan
    ---
    tags:
      - Teaching Plans
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/TeachingPlan'
    responses:
      201:
        description: Teaching plan created
      400:
        description: Validation or creation error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = teaching_plan_service.create_teaching_plan(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(item)), 201

@teaching_plan_bp.route('/<int:id>', methods=['PUT'])
@inject
def update_plan(id: int, teaching_plan_service: TeachingPlanService = Provide[Container.teaching_plan_service]):
    """
    Update a teaching plan
    ---
    tags:
      - Teaching Plans
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/TeachingPlan'
    responses:
      200:
        description: Teaching plan updated
      400:
        description: Validation error
      404:
        description: Teaching plan not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    item = teaching_plan_service.update_teaching_plan(id, data)
    if not item:
        return jsonify({'message': 'Teaching plan not found'}), 404
    return jsonify(schema.dump(item)), 200

@teaching_plan_bp.route('/<int:id>', methods=['DELETE'])
@inject
def delete_plan(id: int, teaching_plan_service: TeachingPlanService = Provide[Container.teaching_plan_service]):
    """
    Delete a teaching plan
    ---
    tags:
      - Teaching Plans
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    responses:
      204:
        description: Deleted
      404:
        description: Teaching plan not found
    """
    ok = teaching_plan_service.delete_teaching_plan(id)
    if not ok:
        return jsonify({'message': 'Teaching plan not found'}), 404
    return '', 204
</file>

<file path="src/api/controllers/user_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.user_service import UserService
from api.schemas.user_schema import UserSchema
from api.middleware import token_required

user_bp = Blueprint('user', __name__, url_prefix='/users')

schema = UserSchema()

@user_bp.route('/', methods=['GET'])
@inject
def list_users(user_service: UserService = Provide[Container.user_service]):
    """Get all users
    ---
    get:
      summary: Get all users
      tags:
        - Users
      responses:
        200:
          description: List of users
    """
    users = user_service.list_users()
    return jsonify(schema.dump(users, many=True)), 200

@user_bp.route('/<int:id>', methods=['GET'])
@inject
def get_user(id: int, user_service: UserService = Provide[Container.user_service]):
    """Get user by id
    ---
    get:
      summary: Get user by ID
      tags:
        - Users
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: User object
        404:
          description: Not found
    """
    user = user_service.get_user(id)
    if not user:
        return jsonify({'message': 'User not found'}), 404
    return jsonify(schema.dump(user)), 200


@user_bp.route('/me', methods=['GET'])
@inject
@token_required
def get_me(user_service: UserService = Provide[Container.user_service]):
    """Get current user from token
    """
    from flask import request
    payload = getattr(request, 'user', None)
    if not payload:
        return jsonify({'message': 'User not found in token'}), 404
    user_id = payload.get('user_id')
    if not user_id:
        return jsonify({'message': 'user_id missing in token'}), 400
    user = user_service.get_user(user_id)
    if not user:
        return jsonify({'message': 'User not found'}), 404
    return jsonify(schema.dump(user)), 200

@user_bp.route('/', methods=['POST'])
@inject
def create_user(user_service: UserService = Provide[Container.user_service]):
    """Create a new user
    ---
    post:
      summary: Create a new user
      tags:
        - Users
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/User'
      responses:
        201:
          description: User created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    user = user_service.create_user(data)
    return jsonify(schema.dump(user)), 201

@user_bp.route('/<int:id>', methods=['PUT'])
@inject
def update_user(id: int, user_service: UserService = Provide[Container.user_service]):
    """Update an existing user
    ---
    put:
      summary: Update user
      tags:
        - Users
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/User'
      responses:
        200:
          description: User updated
        400:
          description: Invalid input
        404:
          description: User not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    user = user_service.update_user(id, data)
    if not user:
        return jsonify({'message': 'User not found'}), 404
    return jsonify(schema.dump(user)), 200
</file>

<file path="src/api/middleware.py">
# Middleware functions for processing requests and responses

from flask import  request, jsonify

def log_request_info(app):
    app.logger.debug('Headers: %s', request.headers)
    app.logger.debug('Body: %s', request.get_data())

def handle_options_request():
    return jsonify({'message': 'CORS preflight response'}), 200

from flask import current_app
from werkzeug.exceptions import HTTPException
import traceback

def error_handling_middleware(error):
    # Handle HTTP exceptions (e.g., BadRequest) with their status codes
    if isinstance(error, HTTPException):
        response = jsonify({'error': error.description})
        response.status_code = error.code or 400
        return response

    # Log unexpected exceptions with traceback
    try:
        current_app.logger.exception(error)
    except Exception:
        pass

    tb = None
    try:
        tb = traceback.format_exc()
    except Exception:
        tb = None

    payload = {'error': str(error)}
    if getattr(current_app, 'debug', False) and tb:
        payload['traceback'] = tb

    response = jsonify(payload)
    response.status_code = 500
    return response

def add_custom_headers(response):
    response.headers['X-Custom-Header'] = 'Value'
    return response

from functools import wraps


def middleware(app):
    @app.before_request
    def before_request():
        log_request_info(app)

    @app.after_request
    def after_request(response):
        return add_custom_headers(response)

    @app.errorhandler(Exception)
    def handle_exception(error):
        return error_handling_middleware(error)

    @app.route('/options', methods=['OPTIONS'])
    def options_route():
        return handle_options_request()


# Token decorator verifying JWT
import jwt
from config import Config

def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        from flask import request, make_response
        # Allow preflight CORS requests through without authentication
        if request.method == 'OPTIONS':
            return make_response('', 200)
        auth = request.headers.get('Authorization', '')
        if not auth or not auth.startswith('Bearer '):
            return jsonify({'message': 'Authorization token is missing'}), 401
        token = auth.split(' ', 1)[1]
        try:
            payload = jwt.decode(token, Config.SECRET_KEY, algorithms=['HS256'])
            # Optionally attach user info to request context
            request.user = payload
        except jwt.ExpiredSignatureError:
            return jsonify({'message': 'Token expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'message': 'Invalid token'}), 401
        return f(*args, **kwargs)

    return decorated
</file>

<file path="src/api/requests.py">
# requests.py

from flask import request, jsonify

def get_request_data():
    """Extracts and returns JSON data from the request."""
    data = request.get_json()
    if not data:
        return jsonify({"error": "No data provided"}), 400
    return data

def validate_request_schema(schema):
    """Validates the incoming request data against the provided schema."""
    data = get_request_data()
    errors = schema.validate(data)
    if errors:
        return jsonify({"errors": errors}), 400
    return data

def handle_get_request():
    """Handles GET requests."""
    # Logic for handling GET requests goes here
    pass

def handle_post_request():
    """Handles POST requests."""
    # Logic for handling POST requests goes here
    pass

def handle_put_request():
    """Handles PUT requests."""
    # Logic for handling PUT requests goes here
    pass

def handle_delete_request():
    """Handles DELETE requests."""
    # Logic for handling DELETE requests goes here
    pass
</file>

<file path="src/api/responses.py">
# src/api/responses.py

from flask import jsonify

def success_response(data, message="Success"):
    return jsonify({"message": message, "data": data}), 200

def error_response(message="An error occurred", status_code=400):
    return jsonify({"message": message}), status_code

def not_found_response(message="Resource not found"):
    return jsonify({"message": message}), 404

def validation_error_response(errors):
    return jsonify({"message": "Validation errors", "errors": errors}), 422
</file>

<file path="src/api/routes.py">
def register_routes(app):
    """Register API routes. No legacy route blueprints are registered for SMD."""
    return
</file>

<file path="src/api/schemas/...  # Marshmallow schemas">
# This file is intentionally left blank.
</file>

<file path="src/api/schemas/academic_year_schema.py">
from marshmallow import Schema, fields

class AcademicYearSchema(Schema):
    id = fields.Int(dump_only=True)
    code = fields.Str(required=True)
    start_date = fields.Date(required=True)
    end_date = fields.Date(required=True)
</file>

<file path="src/api/schemas/assessment_clo_mapping_schema.py">
from marshmallow import Schema, fields

class AssessmentCloMappingSchema(Schema):
    assessment_component_id = fields.Int(required=True)
    syllabus_clo_id = fields.Int(required=True)
</file>

<file path="src/api/schemas/assessment_component_schema.py">
from marshmallow import Schema, fields
from marshmallow.validate import Range

class AssessmentComponentSchema(Schema):
    id = fields.Int(dump_only=True)
    scheme_id = fields.Int(required=True)
    name = fields.Str(required=True)
    weight = fields.Float(required=True, validate=Range(min=0, max=100))
    rubrics = fields.List(fields.Nested('RubricSchema'), dump_only=True)
</file>

<file path="src/api/schemas/assessment_scheme_schema.py">
from marshmallow import Schema, fields
from marshmallow.validate import Range

class AssessmentSchemeSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    name = fields.Str(required=True)
    weight = fields.Float(required=True, validate=Range(min=0, max=100))
    components = fields.List(fields.Nested('AssessmentComponentSchema'), dump_only=True)
</file>

<file path="src/api/schemas/base_schema.py">
from marshmallow import Schema, post_dump
import re

def snake_to_camel(s: str) -> str:
    parts = s.split('_')
    return parts[0] + ''.join(p.capitalize() for p in parts[1:])

def _convert(obj):
    if isinstance(obj, dict):
        new = {}
        for k, v in obj.items():
            nk = snake_to_camel(k)
            new[nk] = _convert(v)
        return new
    elif isinstance(obj, list):
        return [_convert(x) for x in obj]
    else:
        return obj

class BaseSchema(Schema):
    @post_dump
    def to_camel(self, data, many=False, **kwargs):
        # marshmallow may or may not pass `many`; accept it optionally
        if many and isinstance(data, list):
            return [_convert(x) for x in data]
        return _convert(data)
</file>

<file path="src/api/schemas/clo_plo_mapping_schema.py">
from marshmallow import Schema, fields
from marshmallow.validate import OneOf

class CloPloMappingSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_clo_id = fields.Int(required=True)
    program_plo_id = fields.Int(required=True)
    level = fields.Str(required=True, validate=OneOf(['I', 'R', 'M', 'A']))
</file>

<file path="src/api/schemas/department_schema.py">
from marshmallow import Schema, fields

class DepartmentSchema(Schema):
    id = fields.Int(dump_only=True)
    faculty_id = fields.Int(required=True)
    code = fields.Str(required=True)
    name = fields.Str(required=True)
</file>

<file path="src/api/schemas/faculty_schema.py">
from marshmallow import Schema, fields

class FacultySchema(Schema):
    id = fields.Int(dump_only=True)
    code = fields.Str(required=True)
    name = fields.Str(required=True)
    # Optional fields example: use load_default for Marshmallow
    description = fields.Str(load_default=None)
</file>

<file path="src/api/schemas/file_schema.py">
from marshmallow import Schema, fields

class FileSchema(Schema):
    id = fields.Int(dump_only=True)
    uploader_id = fields.Int(dump_only=True)
    file_name = fields.Str(dump_only=True)
    file_path = fields.Str(dump_only=True)
    created_at = fields.DateTime(dump_only=True)
</file>

<file path="src/api/schemas/notification_schema.py">
from marshmallow import Schema, fields

class NotificationSchema(Schema):
    id = fields.Int(dump_only=True)
    user_id = fields.Int(required=True)
    title = fields.Str(required=True)
    message = fields.Str(load_default=None)
    link = fields.Str(load_default=None)
    is_read = fields.Bool(dump_only=True)
    type = fields.Str(load_default='SYSTEM')
    created_at = fields.DateTime(dump_only=True)
</file>

<file path="src/api/schemas/program_outcome_schema.py">
from marshmallow import Schema, fields

class ProgramOutcomeSchema(Schema):
    id = fields.Int(dump_only=True)
    program_id = fields.Int(required=True)
    code = fields.Str(required=True)
    description = fields.Str(required=True)
</file>

<file path="src/api/schemas/program_schema.py">
from marshmallow import Schema, fields

class ProgramSchema(Schema):
    id = fields.Int(dump_only=True)
    department_id = fields.Int(required=True)
    name = fields.Str(required=True)
    total_credits = fields.Int(load_default=0)
</file>

<file path="src/api/schemas/role_schema.py">
from marshmallow import Schema, fields

class RoleSchema(Schema):
    id = fields.Int(dump_only=True)
    name = fields.Str(required=True)
    description = fields.Str(load_default=None)
</file>

<file path="src/api/schemas/rubric_schema.py">
from marshmallow import Schema, fields

class RubricSchema(Schema):
    id = fields.Int(dump_only=True)
    component_id = fields.Int(required=True)
    criteria = fields.Str(required=True)
    max_score = fields.Float(required=True)
    description_level_pass = fields.Str(load_default=None)
    description_level_fail = fields.Str(load_default=None)
</file>

<file path="src/api/schemas/student_schema.py">
from marshmallow import Schema, fields

class StudentSubscriptionSchema(Schema):
    id = fields.Int(dump_only=True)
    student_id = fields.Int(required=True)
    subject_id = fields.Int(required=True)
    created_at = fields.DateTime(dump_only=True)

class StudentReportSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    student_id = fields.Int(required=True)
    content = fields.Str(required=True)
    status = fields.Str(dump_only=True)
    admin_note = fields.Str(load_default=None)
</file>

<file path="src/api/schemas/subject_relationship_schema.py">
from marshmallow import Schema, fields
from marshmallow.validate import OneOf

class SubjectRelationshipSchema(Schema):
    id = fields.Int(dump_only=True)
    subject_id = fields.Int(required=True)
    related_subject_id = fields.Int(required=True)
    type = fields.Str(required=True, validate=OneOf(['PREREQUISITE', 'COREQUISITE', 'PARALLEL']))
</file>

<file path="src/api/schemas/subject_schema.py">
# from marshmallow import Schema, fields

# class SubjectSchema(Schema):
#     id = fields.Int(dump_only=True)
#     department_id = fields.Int(required=True)
#     code = fields.Str(required=True)
#     name_vi = fields.Str(required=True)
#     name_en = fields.Str(required=True)
#     credits = fields.Int(required=True)
#     credit_theory = fields.Float(missing=0)
#     credit_practice = fields.Float(missing=0)
#     credit_self_study = fields.Float(missing=0)
from marshmallow import Schema, fields

class SubjectSchema(Schema):
    id = fields.Int(dump_only=True)
    department_id = fields.Int(required=True)
    code = fields.Str(required=True)
    name_vi = fields.Str(required=True)
    name_en = fields.Str(required=True)
    credits = fields.Int(required=True)
    # S·ª≠a missing=0 th√†nh load_default=0
    credit_theory = fields.Float(load_default=0)
    credit_practice = fields.Float(load_default=0)
    credit_self_study = fields.Float(load_default=0)
</file>

<file path="src/api/schemas/syllabus_clo_schema.py">
from marshmallow import Schema, fields

class SyllabusCloSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    code = fields.Str(required=True)
    description = fields.Str(required=True)
    created_at = fields.DateTime(dump_only=True)
</file>

<file path="src/api/schemas/syllabus_comment_schema.py">
from marshmallow import Schema, fields

class SyllabusCommentSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    user_id = fields.Int(required=True)
    content = fields.Str(required=True)
    parent_id = fields.Int(load_default=None)
    is_resolved = fields.Bool(dump_only=True)
    created_at = fields.DateTime(dump_only=True)
</file>

<file path="src/api/schemas/syllabus_detail_schema.py">
from marshmallow import fields
from .base_schema import BaseSchema

class SyllabusDetailSchema(BaseSchema):
    id = fields.Int(dump_only=True)
    subject_id = fields.Int(required=True)
    program_id = fields.Int(required=True)
    academic_year_id = fields.Int(required=True)
    lecturer_id = fields.Int(required=True)

    status = fields.Str(dump_only=True)
    version = fields.Str(dump_default="1.0")
    time_allocation = fields.Str(load_default=None)
    prerequisites = fields.Str(load_default=None)
    publish_date = fields.DateTime(load_default=None)

    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)

    clos = fields.List(fields.Nested('SyllabusCloSchema'), dump_only=True)
    materials = fields.List(fields.Nested('SyllabusMaterialSchema'), dump_only=True)
    teaching_plans = fields.List(fields.Nested('TeachingPlanSchema'), dump_only=True)
    assessment_schemes = fields.List(fields.Nested('AssessmentSchemeSchema'), dump_only=True)
</file>

<file path="src/api/schemas/syllabus_material_schema.py">
from marshmallow import Schema, fields

class SyllabusMaterialSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    type = fields.Str(required=True)
    title = fields.Str(required=True)
    author = fields.Str(load_default=None)
    publisher = fields.Str(load_default=None)
    isbn = fields.Str(load_default=None)
    url = fields.Str(load_default=None)
</file>

<file path="src/api/schemas/syllabus_schema.py">
import json
from marshmallow import fields, post_dump
from marshmallow.validate import Length
from .base_schema import BaseSchema

class SyllabusSchema(BaseSchema):
    id = fields.Int(dump_only=True)
    subject_id = fields.Int(required=True)
    program_id = fields.Int(required=True)
    academic_year_id = fields.Int(required=True)
    lecturer_id = fields.Int(required=True)

    status = fields.Str(dump_only=True)
    version = fields.Str(load_default="1.0", validate=Length(max=10))
    
    # FIX: time_allocation as Dict
    time_allocation = fields.Dict(allow_none=True)
    prerequisites = fields.Str(load_default=None)
    publish_date = fields.DateTime(load_default=None)

    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)

    # FIX: Add nested fields for input (load_default=[])
    clos = fields.List(fields.Nested('SyllabusCloSchema'), load_default=[])
    materials = fields.List(fields.Nested('SyllabusMaterialSchema'), load_default=[])
    teaching_plans = fields.List(fields.Nested('TeachingPlanSchema'), load_default=[])
    assessment_schemes = fields.List(fields.Nested('AssessmentSchemeSchema'), load_default=[])

    @post_dump
    def parse_json(self, data, **kwargs):
        if 'timeAllocation' in data and isinstance(data['timeAllocation'], str):
            try:
                data['timeAllocation'] = json.loads(data['timeAllocation'])
            except:
                pass
        return data
</file>

<file path="src/api/schemas/system_setting_schema.py">
from marshmallow import Schema, fields

class SystemSettingSchema(Schema):
    key = fields.Str(required=True)
    value = fields.Str(required=True)
    type = fields.Str(dump_only=True)
    description = fields.Str(load_default=None)
</file>

<file path="src/api/schemas/teaching_plan_schema.py">
from marshmallow import Schema, fields

class TeachingPlanSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    week = fields.Int(required=True)
    topic = fields.Str(load_default=None)
    activity = fields.Str(load_default=None)
    assessment = fields.Str(load_default=None)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)
</file>

<file path="src/api/schemas/user_schema.py">
from marshmallow import fields
from .base_schema import BaseSchema

class UserSchema(BaseSchema):
    id = fields.Int(dump_only=True)
    username = fields.Str(required=True)
    email = fields.Email(required=True)
    full_name = fields.Str(required=True)
    department_id = fields.Int(load_default=None)
    is_active = fields.Bool(load_default=True)
    password = fields.Str(load_only=True, required=True)
</file>

<file path="src/api/schemas/user.py">

</file>

<file path="src/api/schemas/workflow_log_schema.py">
from marshmallow import Schema, fields

class WorkflowLogSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    actor_id = fields.Int(required=True)
    action = fields.Str(required=True)
    from_status = fields.Str(load_default=None)
    to_status = fields.Str(load_default=None)
    comment = fields.Str(load_default=None)
    created_at = fields.DateTime(dump_only=True)
</file>

<file path="src/api/swagger.py">
from apispec import APISpec
from apispec.ext.marshmallow import MarshmallowPlugin
from apispec_webframeworks.flask import FlaskPlugin

spec = APISpec(
    title="Syllabus Management API",
    version="1.0.0",
    openapi_version="3.0.2",
    plugins=[FlaskPlugin(), MarshmallowPlugin()],
)

# (No legacy Todo schemas registered ‚Äî SMD module schemas are registered via controllers/schemas)
</file>

<file path="src/app_logging.py">
import logging

def setup_logging():
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler("app.log"),
            logging.StreamHandler()
        ]
    )

setup_logging()
</file>

<file path="src/app.py">
from flask import Flask, jsonify
from api.swagger import spec
from api.middleware import middleware
from infrastructure.databases import init_db
from flasgger import Swagger
from flask_swagger_ui import get_swaggerui_blueprint
from cors import init_cors

# Dependency injection
from dependency_container import Container
from api.controllers.subject_controller import subject_bp
from api.controllers.faculty_controller import faculty_bp
from api.controllers.department_controller import department_bp
from api.controllers.role_controller import role_bp
from api.controllers.user_controller import user_bp
from api.controllers.academic_year_controller import academic_year_bp
from api.controllers.program_controller import program_bp
from api.controllers.syllabus_controller import syllabus_bp
from api.controllers.syllabus_clo_controller import syllabus_clo_bp
from api.controllers.syllabus_material_controller import syllabus_material_bp
from api.controllers.teaching_plan_controller import teaching_plan_bp
from api.controllers.assessment_scheme_controller import assessment_scheme_bp
from api.controllers.assessment_component_controller import assessment_component_bp
from api.controllers.rubric_controller import rubric_bp
from api.controllers.assessment_clo_controller import assessment_clo_bp
from api.controllers.auth_controller import auth_bp
from api.controllers.ai_controller import ai_bp
from api.controllers.dashboard_controller import dashboard_bp
from api.controllers.program_outcome_controller import program_outcome_bp
from api.controllers.file_controller import file_bp
from api.controllers.clo_plo_mapping_controller import clo_plo_mapping_bp
from api.controllers.subject_relationship_controller import subject_rel_bp
from api.controllers.syllabus_comment_controller import syllabus_comment_bp
from api.controllers.notification_controller import notification_bp
from api.controllers.system_setting_controller import system_setting_bp
from api.controllers.student_controller import student_bp


def create_app():
    app = Flask(__name__)

    # Initialize CORS early so Swagger and other blueprints respect it
    try:
        init_cors(app)
    except Exception:
        pass

    Swagger(app)

    # Initialize DI container and wire controllers
    container = Container()
    # Wire the container explicitly for controllers
    try:
        container.wire(modules=[
            "api.controllers.subject_controller",
            "api.controllers.faculty_controller",
            "api.controllers.department_controller",
            "api.controllers.role_controller",
            "api.controllers.user_controller",
            "api.controllers.academic_year_controller",
            "api.controllers.program_controller",
            "api.controllers.syllabus_controller",
            "api.controllers.syllabus_clo_controller",
            "api.controllers.syllabus_material_controller",
            "api.controllers.teaching_plan_controller",
            "api.controllers.assessment_scheme_controller",
            "api.controllers.assessment_component_controller",
            "api.controllers.rubric_controller",
            "api.controllers.assessment_clo_controller",
            "api.controllers.auth_controller",
            "api.controllers.ai_controller",
            "api.controllers.dashboard_controller",
            "api.controllers.program_outcome_controller",
            "api.controllers.file_controller",
            "api.controllers.clo_plo_mapping_controller",
            "api.controllers.subject_relationship_controller",
            "api.controllers.syllabus_comment_controller",
            "api.controllers.notification_controller",
            "api.controllers.system_setting_controller",
            "api.controllers.student_controller",
        ])
    except Exception:
        # best-effort wiring; if it fails here the app can still start
        pass

    # Register blueprints
    app.register_blueprint(subject_bp)
    app.register_blueprint(faculty_bp)
    app.register_blueprint(department_bp)
    app.register_blueprint(role_bp)
    app.register_blueprint(user_bp)
    app.register_blueprint(academic_year_bp)
    app.register_blueprint(program_bp)
    app.register_blueprint(syllabus_bp)
    app.register_blueprint(syllabus_clo_bp)
    app.register_blueprint(syllabus_material_bp)
    app.register_blueprint(teaching_plan_bp)
    app.register_blueprint(assessment_scheme_bp)
    app.register_blueprint(assessment_component_bp)
    app.register_blueprint(rubric_bp)
    app.register_blueprint(assessment_clo_bp)
    app.register_blueprint(auth_bp)
    app.register_blueprint(ai_bp)
    app.register_blueprint(dashboard_bp)
    app.register_blueprint(program_outcome_bp)
    app.register_blueprint(file_bp)
    app.register_blueprint(clo_plo_mapping_bp)
    app.register_blueprint(subject_rel_bp)
    app.register_blueprint(syllabus_comment_bp)
    app.register_blueprint(notification_bp)
    app.register_blueprint(system_setting_bp)
    app.register_blueprint(student_bp)

     # Th√™m Swagger UI blueprint
    SWAGGER_URL = '/docs'
    API_URL = '/swagger.json'
    swaggerui_blueprint = get_swaggerui_blueprint(
        SWAGGER_URL,
        API_URL,
        config={'app_name': "Syllabus Management API"}
    )
    app.register_blueprint(swaggerui_blueprint, url_prefix=SWAGGER_URL)

    try:
        init_db(app)
    except Exception as e:
        print(f"Error initializing database: {e}")

    # Register middleware
    middleware(app)

    # Initialize CORS
    try:
        init_cors(app)
    except Exception:
        pass

    # Register routes (add all non-static endpoints to Swagger where possible)
    with app.test_request_context():
        for rule in app.url_map.iter_rules():
            if rule.endpoint == 'static':
                continue
            view_func = app.view_functions.get(rule.endpoint)
            if not view_func:
                continue
            try:
                spec.path(view=view_func)
                print(f"Adding path: {rule.rule} -> {view_func}")
            except Exception:
                # some endpoints may not be compatible with flasgger, skip them
                pass

    @app.route("/swagger.json")
    def swagger_json():
        return jsonify(spec.to_dict())

    return app
# Run the application

if __name__ == '__main__':
    app = create_app()
    app.run(host='0.0.0.0', port=9999, debug=True)
</file>

<file path="src/config.py">
# Configuration settings for the Flask application

import os
from dotenv import load_dotenv
load_dotenv()

class Config:
    """Base configuration."""
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'a_default_secret_key'
    DEBUG = os.environ.get('DEBUG', 'False').lower() in ['true', '1']
    TESTING = os.environ.get('TESTING', 'False').lower() in ['true', '1']
    
    DATABASE_URI = os.environ.get('DATABASE_URI') 
    CORS_HEADERS = 'Content-Type'

class DevelopmentConfig(Config):
    """Development configuration."""
    DEBUG = True
    DATABASE_URI = os.environ.get('DATABASE_URI') 


class TestingConfig(Config):
    """Testing configuration."""
    TESTING = True
    DATABASE_URI = os.environ.get('DATABASE_URI')


class ProductionConfig(Config):
    """Production configuration."""
    DATABASE_URI = os.environ.get('DATABASE_URI') 

    
template = {
    "swagger": "2.0",
    "info": {
        "title": "Syllabus Management API",
        "description": "API for Syllabus Management (SMD)",
        "version": "1.0.0"
    },
    "basePath": "/",
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ]
}
class SwaggerConfig:
    """Swagger configuration."""
    template = {
        "swagger": "2.0",
        "info": {
            "title": "Syllabus Management API",
            "description": "API for Syllabus Management (SMD)",
            "version": "1.0.0"
        },
        "basePath": "/",
        "schemes": [
            "http",
            "https"
        ],
        "consumes": [
            "application/json"
        ],
        "produces": [
            "application/json"
        ]
    }

    swagger_config = {
        "headers": [],
        "specs": [
            {
                "endpoint": 'apispec',
                "route": '/apispec.json',
                "rule_filter": lambda rule: True,
                "model_filter": lambda tag: True,
            }
        ],
        "static_url_path": "/flasgger_static",
        "swagger_ui": True,
        "specs_route": "/docs"
    }
</file>

<file path="src/cors.py">
from flask_cors import CORS

def init_cors(app):
    # Restrict origins to the frontend (Next.js dev host) and allow Authorization header
    CORS(app, resources={
        r"/*": {
            "origins": ["http://localhost:3000"],
            "allow_headers": ["Authorization", "Content-Type"],
            "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
        }
    }, supports_credentials=True)
    app.config.setdefault('CORS_HEADERS', 'Content-Type')
    return app
</file>

<file path="src/create_app.py">
from flask import Flask
from .config import Config
from .api.middleware import setup_middleware
from .api.routes import register_routes
from .infrastructure.databases import init_db
from .app_logging import setup_logging

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)

    setup_logging(app)
    init_db(app)
    setup_middleware(app)
    register_routes(app)

    return app
</file>

<file path="src/dependency_container.py">
# Dependency Injection Container

from dependency_injector import containers, providers
from infrastructure.databases.mssql import session

from infrastructure.repositories.subject_repository import SubjectRepository
from services.subject_service import SubjectService
from infrastructure.repositories.faculty_repository import FacultyRepository
from services.faculty_service import FacultyService
from infrastructure.repositories.department_repository import DepartmentRepository
from services.department_service import DepartmentService
from infrastructure.repositories.role_repository import RoleRepository
from services.role_service import RoleService
from infrastructure.repositories.user_repository import UserRepository
from services.user_service import UserService
from infrastructure.repositories.academic_year_repository import AcademicYearRepository
from services.academic_year_service import AcademicYearService
from infrastructure.repositories.program_repository import ProgramRepository
from services.program_service import ProgramService
from infrastructure.repositories.syllabus_repository import SyllabusRepository
from services.syllabus_service import SyllabusService
from infrastructure.repositories.syllabus_clo_repository import SyllabusCloRepository
from services.syllabus_clo_service import SyllabusCloService
from infrastructure.repositories.syllabus_material_repository import SyllabusMaterialRepository
from services.syllabus_material_service import SyllabusMaterialService
from infrastructure.repositories.teaching_plan_repository import TeachingPlanRepository
from services.teaching_plan_service import TeachingPlanService
from infrastructure.repositories.assessment_scheme_repository import AssessmentSchemeRepository
from services.assessment_scheme_service import AssessmentSchemeService
from infrastructure.repositories.assessment_component_repository import AssessmentComponentRepository
from services.assessment_component_service import AssessmentComponentService
from infrastructure.repositories.rubric_repository import RubricRepository
from services.rubric_service import RubricService
from infrastructure.repositories.assessment_clo_repository import AssessmentCloRepository
from services.assessment_clo_service import AssessmentCloService
from infrastructure.repositories.workflow_log_repository import WorkflowLogRepository

# NEW: Program Outcome, File Management, Mappings, Relationships, Comments, Notifications, System Settings, AI Audit
from infrastructure.repositories.program_outcome_repository import ProgramOutcomeRepository
from services.program_outcome_service import ProgramOutcomeService
from infrastructure.repositories.file_repository import FileRepository
from services.file_service import FileService
from infrastructure.repositories.clo_plo_mapping_repository import CloPloMappingRepository
from services.clo_plo_mapping_service import CloPloMappingService
from infrastructure.repositories.subject_relationship_repository import SubjectRelationshipRepository
from services.subject_relationship_service import SubjectRelationshipService
from infrastructure.repositories.syllabus_comment_repository import SyllabusCommentRepository
from services.syllabus_comment_service import SyllabusCommentService
from infrastructure.repositories.notification_repository import NotificationRepository
from services.notification_service import NotificationService
from infrastructure.repositories.system_setting_repository import SystemSettingRepository
from infrastructure.repositories.ai_auditlog_repository import AiAuditLogRepository
from infrastructure.repositories.notification_repository import NotificationRepository
from infrastructure.repositories.student_subscription_repository import StudentSubscriptionRepository
from infrastructure.repositories.student_report_repository import StudentReportRepository
from services.system_setting_service import SystemSettingService
from services.student_service import StudentService

class Container(containers.DeclarativeContainer):
    """Dependency Injection Container for SMD services."""

    wiring_config = containers.WiringConfiguration(modules=[
        "api.controllers.subject_controller",
        "api.controllers.faculty_controller",
        "api.controllers.department_controller",
        "api.controllers.role_controller",
        "api.controllers.user_controller",
        "api.controllers.academic_year_controller",
        "api.controllers.program_controller",
        "api.controllers.syllabus_controller",
        "api.controllers.syllabus_clo_controller",
        "api.controllers.syllabus_material_controller",
        "api.controllers.teaching_plan_controller",
        "api.controllers.assessment_scheme_controller",
        "api.controllers.assessment_component_controller",
        "api.controllers.rubric_controller",
        "api.controllers.assessment_clo_controller",
        "api.controllers.auth_controller",
        "api.controllers.ai_controller",
        "api.controllers.dashboard_controller",
        "api.controllers.program_outcome_controller",
        "api.controllers.file_controller",
        "api.controllers.clo_plo_mapping_controller",
        "api.controllers.subject_relationship_controller",
        "api.controllers.syllabus_comment_controller",
        "api.controllers.notification_controller",
        "api.controllers.system_setting_controller",
        "api.controllers.student_controller",
    ])

    # Provide a session object (singleton)
    db_session = providers.Object(session)

    # Repositories
    subject_repository = providers.Factory(
        SubjectRepository,
        session=db_session
    )

    faculty_repository = providers.Factory(
        FacultyRepository,
        session=db_session
    )

    department_repository = providers.Factory(
        DepartmentRepository,
        session=db_session
    )

    academic_year_repository = providers.Factory(
        AcademicYearRepository,
        session=db_session
    )

    program_repository = providers.Factory(
        ProgramRepository,
        session=db_session
    )

    role_repository = providers.Factory(
        RoleRepository,
        session=db_session
    )

    user_repository = providers.Factory(
        UserRepository,
        session=db_session
    )
    # Services
    subject_service = providers.Factory(
        SubjectService,
        repository=subject_repository
    )

    faculty_service = providers.Factory(
        FacultyService,
        repository=faculty_repository
    )

    department_service = providers.Factory(
        DepartmentService,
        repository=department_repository
    )

    syllabus_repository = providers.Factory(
        SyllabusRepository,
        session=db_session
    )

    syllabus_clo_repository = providers.Factory(
        SyllabusCloRepository,
        session=db_session
    )

    syllabus_material_repository = providers.Factory(
        SyllabusMaterialRepository,
        session=db_session
    )

    teaching_plan_repository = providers.Factory(
        TeachingPlanRepository,
        session=db_session
    )

    assessment_scheme_repository = providers.Factory(
        AssessmentSchemeRepository,
        session=db_session
    )

    assessment_component_repository = providers.Factory(
        AssessmentComponentRepository,
        session=db_session
    )

    rubric_repository = providers.Factory(
        RubricRepository,
        session=db_session
    )

    assessment_clo_repository = providers.Factory(
        AssessmentCloRepository,
        session=db_session
    )

    workflow_log_repository = providers.Factory(
        WorkflowLogRepository,
        session=db_session
    )

    # NEW REPOSITORIES
    program_outcome_repository = providers.Factory(
        ProgramOutcomeRepository,
        session=db_session
    )
    
    file_repository = providers.Factory(
        FileRepository,
        session=db_session
    )

    clo_plo_mapping_repository = providers.Factory(
        CloPloMappingRepository,
        session=db_session
    )

    subject_relationship_repository = providers.Factory(
        SubjectRelationshipRepository,
        session=db_session
    )

    syllabus_comment_repository = providers.Factory(
        SyllabusCommentRepository,
        session=db_session
    )

    notification_repository = providers.Factory(
        NotificationRepository,
        session=db_session
    )

    system_setting_repository = providers.Factory(
        SystemSettingRepository,
        session=db_session
    )

    student_subscription_repository = providers.Factory(
        StudentSubscriptionRepository,
        session=db_session
    )

    student_report_repository = providers.Factory(
        StudentReportRepository,
        session=db_session
    )

    ai_auditlog_repository = providers.Factory(
        AiAuditLogRepository,
        session=db_session
    )

    academic_year_service = providers.Factory(
        AcademicYearService,
        repository=academic_year_repository
    )

    program_service = providers.Factory(
        ProgramService,
        repository=program_repository
    )

    syllabus_service = providers.Factory(
        SyllabusService,
        repository=syllabus_repository,
        subject_repository=subject_repository,
        program_repository=program_repository,
        academic_year_repository=academic_year_repository,
        user_repository=user_repository,
        workflow_log_repository=workflow_log_repository,
        # NEW INJECTIONS:
        syllabus_clo_repository=syllabus_clo_repository,
        syllabus_material_repository=syllabus_material_repository,
        teaching_plan_repository=teaching_plan_repository,
        assessment_scheme_repository=assessment_scheme_repository,
        assessment_component_repository=assessment_component_repository,
        rubric_repository=rubric_repository,
        assessment_clo_repository=assessment_clo_repository
    )

    syllabus_clo_service = providers.Factory(
        SyllabusCloService,
        repository=syllabus_clo_repository,
        syllabus_repository=syllabus_repository
    )

    syllabus_material_service = providers.Factory(
        SyllabusMaterialService,
        repository=syllabus_material_repository,
        syllabus_repository=syllabus_repository
    )

    teaching_plan_service = providers.Factory(
        TeachingPlanService,
        repository=teaching_plan_repository,
        syllabus_repository=syllabus_repository
    )

    assessment_scheme_service = providers.Factory(
        AssessmentSchemeService,
        repository=assessment_scheme_repository,
        syllabus_repository=syllabus_repository
    )

    assessment_component_service = providers.Factory(
        AssessmentComponentService,
        repository=assessment_component_repository,
        scheme_repository=assessment_scheme_repository
    )

    rubric_service = providers.Factory(
        RubricService,
        repository=rubric_repository,
        component_repository=assessment_component_repository
    )

    assessment_clo_service = providers.Factory(
        AssessmentCloService,
        repository=assessment_clo_repository,
        component_repository=assessment_component_repository,
        syllabus_clo_repository=syllabus_clo_repository,
        assessment_scheme_repository=assessment_scheme_repository
    )
  

    # NEW SERVICES
    program_outcome_service = providers.Factory(
        ProgramOutcomeService,
        repository=program_outcome_repository,
        program_repository=program_repository
    )

    file_service = providers.Factory(
        FileService,
        repository=file_repository
    )

    clo_plo_mapping_service = providers.Factory(
        CloPloMappingService,
        repository=clo_plo_mapping_repository,
        syllabus_clo_repository=syllabus_clo_repository,
        program_outcome_repository=program_outcome_repository
    )

    subject_relationship_service = providers.Factory(
        SubjectRelationshipService,
        repository=subject_relationship_repository,
        subject_repository=subject_repository
    )

    syllabus_comment_service = providers.Factory(
        SyllabusCommentService,
        repository=syllabus_comment_repository,
        syllabus_repository=syllabus_repository,
        user_repository=user_repository
    )

    notification_service = providers.Factory(
        NotificationService,
        repository=notification_repository,
        user_repository=user_repository
    )

    system_setting_service = providers.Factory(
        SystemSettingService,
        repository=system_setting_repository
    )

    student_service = providers.Factory(
        StudentService, 
        sub_repo=student_subscription_repository,
        report_repo=student_report_repository
    )

    # AI Service (inject audit repository)
    from services.ai_service import AiService
    ai_service = providers.Factory(
        AiService,
        audit_repository=ai_auditlog_repository
    )

    role_service = providers.Factory(
        RoleService,
        repository=role_repository
    )

    user_service = providers.Factory(
        UserService,
        repository=user_repository
    )

    # AI Service
    from services.ai_service import AiService
    ai_service = providers.Factory(
        AiService
    )
</file>

<file path="src/domain/constants.py">
# Constants

# Define any constants used throughout the application here. 
# For example, you might define API version, error messages, or configuration keys.

API_VERSION = "v1"
DEFAULT_PAGE_SIZE = 20
MAX_PAGE_SIZE = 100

# Add more constants as needed for your application.
</file>

<file path="src/domain/exceptions.py">
class CustomException(Exception):
    """Base class for all custom exceptions in the application."""
    pass

class NotFoundException(CustomException):
    """Exception raised when a resource is not found."""
    def __init__(self, message="Resource not found"):
        self.message = message
        super().__init__(self.message)

class ValidationException(CustomException):
    """Exception raised for validation errors."""
    def __init__(self, message="Validation error"):
        self.message = message
        super().__init__(self.message)

class UnauthorizedException(CustomException):
    """Exception raised for unauthorized access."""
    def __init__(self, message="Unauthorized access"):
        self.message = message
        super().__init__(self.message)

class ConflictException(CustomException):
    """Exception raised for conflicts in the application."""
    def __init__(self, message="Conflict occurred"):
        self.message = message
        super().__init__(self.message)
</file>

<file path="src/domain/models/...  # Business logic models">
# This file is intentionally left blank.
</file>

<file path="src/domain/models/user.py">
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from infrastructure.databases.base import Base

class User:
    
    def __innit__(self, user_name: str, password: str, description: str = None, status: bool = True):
        self.user_name = user_name
        self.password = password
        self.description = description
        self.status = status
        self.created_at = None
        self.updated_at = None
</file>

<file path="src/error_handler.py">
# Error handling logic for the Flask application

from flask import jsonify

class CustomError(Exception):
    status_code = 400

    def __init__(self, message, status_code=None):
        super().__init__(message)
        if status_code is not None:
            self.status_code = status_code
        self.message = message

    def to_dict(self):
        return {'message': self.message}

def handle_error(error):
    if isinstance(error, CustomError):
        response = jsonify(error.to_dict())
        response.status_code = error.status_code
        return response

    response = jsonify({'message': 'An unexpected error occurred.'})
    response.status_code = 500
    return response

def register_error_handlers(app):
    app.register_error_handler(Exception, handle_error)
</file>

<file path="src/infrastructure/databases/__init__.py">
from infrastructure.databases.mssql import init_mssql
from infrastructure.models import (
    academic_year_model,
    ai_auditlog_model,
    assessment_clo_model,
    assessment_component_model,
    assessment_scheme_model,
    clo_plo_mapping_model,
    department_model,
    faculty_model,
    file_model,
    notification_model,
    notification_template_model,
    program_model,
    program_outcome_model,
    role_model,
    rubric_model,
    student_report_model,
    student_subscription_model,
    subject_model,
    subject_relationship_model,
    syllabus_clo_model,
    syllabus_comment_model,
    syllabus_current_workflow,
    syllabus_material_model,
    syllabus_model,
    system_auditlog_model,
    system_setting_model,
    teaching_plan_model,
    user_model,
    user_role_model,
    workflow_log_model,
    workflow_state_model,
    workflow_transition_model
)

def init_db(app):
    init_mssql(app)

# Migration Entities -> tables
from infrastructure.databases.mssql import Base
</file>

<file path="src/infrastructure/databases/base.py">
from sqlalchemy.orm import declarative_base

Base = declarative_base()


# ORM: object relational mapping base class
# OOP : object oriented programming

# ERD --> class relational
# L·∫≠p trinhf h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng (logic) mapping class -> table (database)
</file>

<file path="src/infrastructure/databases/mssql.py">
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from config import Config
from infrastructure.databases.base import Base

# Database configuration
DATABASE_URI = Config.DATABASE_URI
engine = create_engine(DATABASE_URI)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
session = SessionLocal()
def init_mssql(app):
    Base.metadata.create_all(bind=engine)
</file>

<file path="src/infrastructure/databases/mysql.py">

</file>

<file path="src/infrastructure/models/__init__.py">
from .user_model import User
from .user_role_model import UserRole
from .role_model import Role
from .faculty_model import Faculty
from .department_model import Department
from .program_model import Program
from .program_outcome_model import ProgramOutcome
from .subject_model import Subject
from .academic_year_model import AcademicYear
from .syllabus_model import Syllabus
from .syllabus_clo_model import SyllabusClo
from .syllabus_material_model import SyllabusMaterial
from .teaching_plan_model import TeachingPlan
from .assessment_scheme_model import AssessmentScheme
from .assessment_component_model import AssessmentComponent
from .rubric_model import Rubric
from .clo_plo_mapping_model import CloPloMapping

__all__ = [
    "User", "UserRole", "Role", "Faculty", "Department", "Program",
    "ProgramOutcome", "Subject", "AcademicYear", "Syllabus", "SyllabusClo",
    "SyllabusMaterial", "TeachingPlan", "AssessmentScheme", "AssessmentComponent", "Rubric",
    "CloPloMapping"
]
</file>

<file path="src/infrastructure/models/academic_year_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class AcademicYear(Base):
    __tablename__ = 'academic_years'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    code = Column(NVARCHAR(20), unique=True)
    start_date = Column(Date)
    end_date = Column(Date)
    
    # Relationships
    syllabuses = relationship("Syllabus", back_populates="academic_year")
</file>

<file path="src/infrastructure/models/ai_auditlog_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class AiAuditLog(Base):
    __tablename__ = 'ai_audit_logs'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id'), nullable=False)
    action = Column(NVARCHAR(50))  # GENERATE, COMPARE_DIFF, SUMMARIZE
    input_tokens = Column(Integer)
    output_tokens = Column(Integer)
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="ai_audit_logs")
</file>

<file path="src/infrastructure/models/assessment_clo_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class AssessmentClo(Base):
    __tablename__ = 'assessment_clos'
    
    assessment_component_id = Column(BigInteger, ForeignKey('assessment_components.id'), primary_key=True)
    syllabus_clo_id = Column(BigInteger, ForeignKey('syllabus_clos.id'), primary_key=True)
    
    # Relationships
    component = relationship("AssessmentComponent", back_populates="clos")
    syllabus_clo = relationship("SyllabusClo", back_populates="assessment_clos")
</file>

<file path="src/infrastructure/models/assessment_component_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class AssessmentComponent(Base):
    __tablename__ = 'assessment_components'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    scheme_id = Column(BigInteger, ForeignKey('assessment_schemes.id'), nullable=False)
    name = Column(NVARCHAR(255), nullable=False)
    weight = Column(DECIMAL(3, 1), nullable=False)
    
    # Relationships
    scheme = relationship("AssessmentScheme", back_populates="components")
    clos = relationship("AssessmentClo", back_populates="component")
    rubrics = relationship("Rubric", back_populates="component", cascade="all, delete-orphan")
</file>

<file path="src/infrastructure/models/assessment_scheme_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class AssessmentScheme(Base):
    __tablename__ = 'assessment_schemes'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id', ondelete='CASCADE'), nullable=False)
    name = Column(NVARCHAR(100))
    weight = Column(DECIMAL(3, 1))
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="assessment_schemes")
    components = relationship("AssessmentComponent", back_populates="scheme", cascade="all, delete-orphan")
</file>

<file path="src/infrastructure/models/clo_plo_mapping_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class CloPloMapping(Base):
    __tablename__ = 'clo_plo_mappings'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_clo_id = Column(BigInteger, ForeignKey('syllabus_clos.id', ondelete='CASCADE'), nullable=False)
    program_plo_id = Column(BigInteger, ForeignKey('program_outcomes.id'), nullable=False)
    level = Column(NVARCHAR(1))  # I, R, M, A
    
    __table_args__ = (
        CheckConstraint("level IN ('I', 'R', 'M', 'A')", name='check_level'),
    )
    
    # Relationships
    syllabus_clo = relationship("SyllabusClo", back_populates="plo_mappings")
    program_plo = relationship("ProgramOutcome", back_populates="clo_mappings")
</file>

<file path="src/infrastructure/models/department_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class Department(Base):
    __tablename__ = 'departments'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    faculty_id = Column(BigInteger, ForeignKey('faculties.id'), nullable=False)
    code = Column(NVARCHAR(20), unique=True, nullable=False)
    name = Column(NVARCHAR(255), nullable=False)
    
    # Relationships
    faculty = relationship("Faculty", back_populates="departments")
    users = relationship("User", back_populates="department")
    subjects = relationship("Subject", back_populates="department")
    programs = relationship("Program", back_populates="department")
</file>

<file path="src/infrastructure/models/faculty_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base


class Faculty(Base):
    __tablename__ = 'faculties'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    code = Column(NVARCHAR(20), unique=True, nullable=False)
    name = Column(NVARCHAR(255), nullable=False)
    
    # Relationships
    departments = relationship("Department", back_populates="faculty")
</file>

<file path="src/infrastructure/models/file_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
# IMPORT BASE CHUNG (QUAN TR·ªåNG)
from infrastructure.databases.base import Base

class File(Base):
    __tablename__ = 'files'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    uploader_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    file_name = Column(NVARCHAR(255), nullable=False)
    file_path = Column(NVARCHAR(500), nullable=False)
    file_size = Column(BigInteger)
    mime_type = Column(NVARCHAR(100))
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    uploader = relationship("User", back_populates="uploaded_files", foreign_keys=[uploader_id])
</file>

<file path="src/infrastructure/models/notification_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class Notification(Base):
    __tablename__ = 'notifications'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    user_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    title = Column(NVARCHAR(255), nullable=False)
    message = Column(UnicodeText)
    link = Column(NVARCHAR(500))
    is_read = Column(Boolean, default=False)
    type = Column(NVARCHAR(50))  # SYSTEM, REVIEW, REMINDER
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    user = relationship("User", back_populates="notifications")
</file>

<file path="src/infrastructure/models/notification_template_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class NotificationTemplate(Base):
    __tablename__ = 'notification_templates'
    
    code = Column(NVARCHAR(50), primary_key=True)
    title_template = Column(NVARCHAR(255), nullable=False)
    body_template = Column(UnicodeText, nullable=False)
    channel = Column(NVARCHAR(20), default='SYSTEM')  # EMAIL, SMS, SYSTEM
</file>

<file path="src/infrastructure/models/program_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class Program(Base):
    __tablename__ = 'programs'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    department_id = Column(BigInteger, ForeignKey('departments.id'), nullable=False)
    name = Column(NVARCHAR(255), nullable=False)
    total_credits = Column(Integer)
    
    # Relationships
    department = relationship("Department", back_populates="programs")
    outcomes = relationship("ProgramOutcome", back_populates="program")
    syllabuses = relationship("Syllabus", back_populates="program")
</file>

<file path="src/infrastructure/models/program_outcome_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class ProgramOutcome(Base):
    __tablename__ = 'program_outcomes'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    program_id = Column(BigInteger, ForeignKey('programs.id'), nullable=False)
    code = Column(NVARCHAR(20))
    description = Column(UnicodeText)
    
    # Relationships
    program = relationship("Program", back_populates="outcomes")
    clo_mappings = relationship("CloPloMapping", back_populates="program_plo")
</file>

<file path="src/infrastructure/models/role_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class Role(Base):
    __tablename__ = 'roles'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    name = Column(NVARCHAR(50), unique=True, nullable=False)
    description = Column(NVARCHAR(255), nullable=True)
    
    # Relationships
    user_roles = relationship("UserRole", back_populates="role")
    workflow_transitions = relationship("WorkflowTransition", back_populates="allowed_role")
</file>

<file path="src/infrastructure/models/rubric_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class Rubric(Base):
    __tablename__ = 'rubrics'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    component_id = Column(BigInteger, ForeignKey('assessment_components.id', ondelete='CASCADE'), nullable=False)
    criteria = Column(UnicodeText, nullable=False)
    max_score = Column(DECIMAL(3, 1), nullable=False)
    description_level_pass = Column(UnicodeText)
    description_level_fail = Column(UnicodeText)
    
    # Relationships
    component = relationship("AssessmentComponent", back_populates="rubrics")
</file>

<file path="src/infrastructure/models/student_report_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class StudentReport(Base):
    __tablename__ = 'student_reports'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id'), nullable=False)
    student_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    content = Column(UnicodeText, nullable=False)
    status = Column(NVARCHAR(20), default='PENDING')  # PENDING, RESOLVED, REJECTED
    admin_note = Column(UnicodeText)
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="student_reports")
    student = relationship("User")
</file>

<file path="src/infrastructure/models/student_subscription_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class StudentSubscription(Base):
    __tablename__ = 'student_subscriptions'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    student_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    subject_id = Column(BigInteger, ForeignKey('subjects.id'), nullable=False)
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    student = relationship("User")
    subject = relationship("Subject", back_populates="student_subscriptions")
</file>

<file path="src/infrastructure/models/subject_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class Subject(Base):
    __tablename__ = 'subjects'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    department_id = Column(BigInteger, ForeignKey('departments.id'), nullable=False)
    code = Column(NVARCHAR(20), unique=True, nullable=False)
    name_vi = Column(NVARCHAR(255), nullable=False)
    name_en = Column(NVARCHAR(255), nullable=False)
    credits = Column(Integer, nullable=False)
    credit_theory = Column(DECIMAL(3, 1), default=0)
    credit_practice = Column(DECIMAL(3, 1), default=0)
    credit_self_study = Column(DECIMAL(3, 1), default=0)
    
    # Relationships
    department = relationship("Department", back_populates="subjects")
    syllabuses = relationship("Syllabus", back_populates="subject")
    subject_relationships = relationship("SubjectRelationship", 
                                        foreign_keys="SubjectRelationship.subject_id",
                                        back_populates="subject")
    related_subjects = relationship("SubjectRelationship",
                                   foreign_keys="SubjectRelationship.related_subject_id",
                                   back_populates="related_subject")
    student_subscriptions = relationship("StudentSubscription", back_populates="subject")
</file>

<file path="src/infrastructure/models/subject_relationship_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class SubjectRelationship(Base):
    __tablename__ = 'subject_relationships'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    subject_id = Column(BigInteger, ForeignKey('subjects.id'), nullable=False)
    related_subject_id = Column(BigInteger, ForeignKey('subjects.id'), nullable=False)
    type = Column(NVARCHAR(20), nullable=False)  # PREREQUISITE, COREQUISITE, PARALLEL
    
    # Relationships
    subject = relationship("Subject", foreign_keys=[subject_id], back_populates="subject_relationships")
    related_subject = relationship("Subject", foreign_keys=[related_subject_id], back_populates="related_subjects")
</file>

<file path="src/infrastructure/models/syllabus_clo_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class SyllabusClo(Base):
    __tablename__ = 'syllabus_clos'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id', ondelete='CASCADE'), nullable=False)
    code = Column(NVARCHAR(20), nullable=False)
    description = Column(UnicodeText, nullable=False)
    embedding_vector = Column(UnicodeText, nullable=True)  # JSON vector
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="clos")
    plo_mappings = relationship("CloPloMapping", back_populates="syllabus_clo", cascade="all, delete-orphan")
    assessment_clos = relationship("AssessmentClo", back_populates="syllabus_clo")
</file>

<file path="src/infrastructure/models/syllabus_comment_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class SyllabusComment(Base):
    __tablename__ = 'syllabus_comments'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id'), nullable=False)
    user_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    content = Column(UnicodeText, nullable=False)
    parent_id = Column(BigInteger, ForeignKey('syllabus_comments.id'), nullable=True)
    is_resolved = Column(Boolean, default=False)
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="comments")
    user = relationship("User", back_populates="comments")
    parent = relationship("SyllabusComment", remote_side=[id], backref="replies")
</file>

<file path="src/infrastructure/models/syllabus_current_workflow.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class SyllabusCurrentWorkflow(Base):
    __tablename__ = 'syllabus_current_workflows'
    
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id'), primary_key=True)
    current_state_id = Column(BigInteger, ForeignKey('workflow_states.id'), nullable=False)
    assigned_to_user_id = Column(BigInteger, ForeignKey('users.id'), nullable=True)
    due_date = Column(DateTime, nullable=True)
    updated_at = Column(DateTime, default=func.now())
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="current_workflow")
    current_state = relationship("WorkflowState", back_populates="current_workflows")
    assigned_to_user = relationship("User")
</file>

<file path="src/infrastructure/models/syllabus_material_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class SyllabusMaterial(Base):
    __tablename__ = 'syllabus_materials'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id', ondelete='CASCADE'), nullable=False)
    type = Column(NVARCHAR(50), nullable=False)  # MAIN, REFERENCE
    title = Column(NVARCHAR(555), nullable=False)
    author = Column(NVARCHAR(255))
    publisher = Column(NVARCHAR(255))
    published_year = Column(Integer)
    isbn = Column(NVARCHAR(50))
    url = Column(UnicodeText, nullable=True)
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="materials")
</file>

<file path="src/infrastructure/models/syllabus_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from sqlalchemy.dialects.mssql import NVARCHAR
from infrastructure.databases.base import Base

class Syllabus(Base):
    __tablename__ = 'syllabuses'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    subject_id = Column(BigInteger, ForeignKey('subjects.id'), nullable=False)
    program_id = Column(BigInteger, ForeignKey('programs.id'), nullable=False)
    academic_year_id = Column(BigInteger, ForeignKey('academic_years.id'), nullable=False)
    lecturer_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    status = Column(NVARCHAR(20))  # DRAFT, PENDING, APPROVED
    version = Column(NVARCHAR(10))
    time_allocation = Column(UnicodeText)  # JSON
    prerequisites = Column(UnicodeText)
    publish_date = Column(DateTime)
    is_active = Column(Boolean)
    embedding_vector = Column(UnicodeText, nullable=True)  # JSON vector
    created_at = Column(DateTime, default=func.now())
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())
    
    # Relationships
    subject = relationship("Subject", back_populates="syllabuses")
    program = relationship("Program", back_populates="syllabuses")
    academic_year = relationship("AcademicYear", back_populates="syllabuses")
    lecturer = relationship("User", back_populates="syllabuses")
    clos = relationship("SyllabusClo", back_populates="syllabus", cascade="all, delete-orphan")
    materials = relationship("SyllabusMaterial", back_populates="syllabus", cascade="all, delete-orphan")
    teaching_plans = relationship("TeachingPlan", back_populates="syllabus", cascade="all, delete-orphan")
    assessment_schemes = relationship("AssessmentScheme", back_populates="syllabus", cascade="all, delete-orphan")
    comments = relationship("SyllabusComment", back_populates="syllabus")
    workflow_logs = relationship("WorkflowLog", back_populates="syllabus")
    current_workflow = relationship("SyllabusCurrentWorkflow", back_populates="syllabus", uselist=False)
    student_reports = relationship("StudentReport", back_populates="syllabus")
    ai_audit_logs = relationship("AiAuditLog", back_populates="syllabus")
</file>

<file path="src/infrastructure/models/system_auditlog_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class SystemAuditLog(Base):
    __tablename__ = 'system_audit_logs'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    user_id = Column(BigInteger, ForeignKey('users.id'), nullable=True)
    action_type = Column(NVARCHAR(50), nullable=False)
    resource_target = Column(NVARCHAR(100))
    ip_address = Column(NVARCHAR(45))
    user_agent = Column(UnicodeText)
    details = Column(UnicodeText)
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    user = relationship("User")
</file>

<file path="src/infrastructure/models/system_setting_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from sqlalchemy.dialects.mssql import NVARCHAR
from infrastructure.databases.base import Base

class SystemSetting(Base):
    __tablename__ = 'system_settings'
    
    key = Column(NVARCHAR(50), primary_key=True)
    value = Column(UnicodeText, nullable=False)
    type = Column(NVARCHAR(20), default='STRING')
    description = Column(NVARCHAR(255), nullable=True)
</file>

<file path="src/infrastructure/models/teaching_plan_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class TeachingPlan(Base):
    __tablename__ = 'teaching_plans'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id', ondelete='CASCADE'), nullable=False)
    week = Column(Integer)
    topic = Column(UnicodeText)
    activity = Column(UnicodeText)
    assessment = Column(UnicodeText)
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="teaching_plans")
</file>

<file path="src/infrastructure/models/user_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
# IMPORT BASE CHUNG (QUAN TR·ªåNG)
from infrastructure.databases.base import Base

class User(Base):
    __tablename__ = 'users'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    department_id = Column(BigInteger, ForeignKey('departments.id'), nullable=True)
    username = Column(NVARCHAR(50), unique=True, nullable=False)
    email = Column(NVARCHAR(100), unique=True, nullable=False)
    password_hash = Column(NVARCHAR(255), nullable=False)
    full_name = Column(NVARCHAR(100), nullable=False)
    is_active = Column(Boolean, default=True)
    
    # S·ª¨A L·ªñI V√íNG L·∫∂P: Th√™m use_alter=True
    avatar_file_id = Column(BigInteger, ForeignKey('files.id', use_alter=True, name='fk_user_avatar_file'), nullable=True)
    
    # Relationships
    department = relationship("Department", back_populates="users")
    
    # L∆∞u √Ω: C·∫≠p nh·∫≠t t√™n relationship n·∫øu file_model d√πng t√™n class l√† File
    avatar_file = relationship("File", foreign_keys=[avatar_file_id])
    uploaded_files = relationship("File", back_populates="uploader", foreign_keys="File.uploader_id")
    
    roles = relationship("UserRole", back_populates="user")
    syllabuses = relationship("Syllabus", back_populates="lecturer")
    comments = relationship("SyllabusComment", back_populates="user")
    notifications = relationship("Notification", back_populates="user")
    workflow_logs = relationship("WorkflowLog", back_populates="actor")
</file>

<file path="src/infrastructure/models/user_role_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class UserRole(Base):
    __tablename__ = 'user_roles'
    
    user_id = Column(BigInteger, ForeignKey('users.id'), primary_key=True)
    role_id = Column(BigInteger, ForeignKey('roles.id'), primary_key=True)
    
    # Relationships
    user = relationship("User", back_populates="roles")
    role = relationship("Role", back_populates="user_roles")
</file>

<file path="src/infrastructure/models/workflow_log_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from sqlalchemy.dialects.mssql import NVARCHAR
from infrastructure.databases.base import Base


class WorkflowLog(Base):
    __tablename__ = 'workflow_logs'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id'), nullable=False)
    actor_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    action = Column(NVARCHAR(50))  # SUBMIT, APPROVE, REJECT
    from_status = Column(NVARCHAR(50))
    to_status = Column(NVARCHAR(50))
    comment = Column(UnicodeText)
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="workflow_logs")
    actor = relationship("User", back_populates="workflow_logs")
</file>

<file path="src/infrastructure/models/workflow_state_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class WorkflowState(Base):
    __tablename__ = 'workflow_states'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    code = Column(NVARCHAR(50), unique=True, nullable=False)
    name = Column(NVARCHAR(100), nullable=False)
    color = Column(NVARCHAR(20))
    is_final = Column(Boolean, default=False)
    
    # Relationships
    transitions_from = relationship("WorkflowTransition", 
                                   foreign_keys="WorkflowTransition.from_state_id",
                                   back_populates="from_state")
    transitions_to = relationship("WorkflowTransition",
                                 foreign_keys="WorkflowTransition.to_state_id",
                                 back_populates="to_state")
    current_workflows = relationship("SyllabusCurrentWorkflow", back_populates="current_state")
</file>

<file path="src/infrastructure/models/workflow_transition_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class WorkflowTransition(Base):
    __tablename__ = 'workflow_transitions'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    from_state_id = Column(BigInteger, ForeignKey('workflow_states.id'), nullable=False)
    to_state_id = Column(BigInteger, ForeignKey('workflow_states.id'), nullable=False)
    allowed_role_id = Column(BigInteger, ForeignKey('roles.id'), nullable=False)
    action_name = Column(NVARCHAR(50))
    
    # Relationships
    from_state = relationship("WorkflowState", foreign_keys=[from_state_id], back_populates="transitions_from")
    to_state = relationship("WorkflowState", foreign_keys=[to_state_id], back_populates="transitions_to")
    allowed_role = relationship("Role", back_populates="workflow_transitions")
</file>

<file path="src/infrastructure/repositories/academic_year_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.academic_year_model import AcademicYear

class AcademicYearRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[AcademicYear]:
        return self.session.query(AcademicYear).all()

    def get_by_id(self, id: int) -> Optional[AcademicYear]:
        return self.session.query(AcademicYear).filter_by(id=id).first()

    def create(self, data: dict) -> AcademicYear:
        ay = AcademicYear(**data)
        self.session.add(ay)
        self.session.commit()
        self.session.refresh(ay)
        return ay

    def update(self, id: int, data: dict) -> Optional[AcademicYear]:
        ay = self.get_by_id(id)
        if not ay:
            return None
        for key, value in data.items():
            if hasattr(ay, key):
                setattr(ay, key, value)
        self.session.commit()
        self.session.refresh(ay)
        return ay

    def delete(self, id: int) -> bool:
        ay = self.get_by_id(id)
        if not ay:
            return False
        self.session.delete(ay)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/ai_auditlog_repository.py">
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.ai_auditlog_model import AiAuditLog

class AiAuditLogRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def create(self, syllabus_id: int, action: str, input_tokens: int, output_tokens: int):
        log = AiAuditLog(syllabus_id=syllabus_id, action=action, input_tokens=input_tokens, output_tokens=output_tokens)
        self.session.add(log)
        self.session.commit()
        return log
</file>

<file path="src/infrastructure/repositories/assessment_clo_repository.py">
from typing import List
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.assessment_clo_model import AssessmentClo
from infrastructure.models.syllabus_clo_model import SyllabusClo

class AssessmentCloRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def add_mapping(self, component_id: int, syllabus_clo_id: int) -> AssessmentClo:
        mapping = AssessmentClo(assessment_component_id=component_id, syllabus_clo_id=syllabus_clo_id)
        self.session.add(mapping)
        self.session.commit()
        return mapping

    def remove_mapping(self, component_id: int, syllabus_clo_id: int) -> bool:
        mapping = self.session.query(AssessmentClo).filter_by(assessment_component_id=component_id, syllabus_clo_id=syllabus_clo_id).first()
        if not mapping:
            return False
        self.session.delete(mapping)
        self.session.commit()
        return True

    def get_clos_by_component(self, component_id: int) -> List[SyllabusClo]:
        mappings = self.session.query(AssessmentClo).filter_by(assessment_component_id=component_id).all()
        return [m.syllabus_clo for m in mappings]
</file>

<file path="src/infrastructure/repositories/assessment_component_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.assessment_component_model import AssessmentComponent

class AssessmentComponentRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[AssessmentComponent]:
        return self.session.query(AssessmentComponent).filter_by(id=id).first()

    def create(self, data: dict) -> AssessmentComponent:
        item = AssessmentComponent(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def update(self, id: int, data: dict) -> Optional[AssessmentComponent]:
        item = self.get_by_id(id)
        if not item:
            return None
        for k, v in data.items():
            if hasattr(item, k):
                setattr(item, k, v)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/assessment_scheme_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session, joinedload
from infrastructure.databases.mssql import session
from infrastructure.models.assessment_scheme_model import AssessmentScheme

class AssessmentSchemeRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[AssessmentScheme]:
        return self.session.query(AssessmentScheme).all()

    def get_by_id(self, id: int) -> Optional[AssessmentScheme]:
        return self.session.query(AssessmentScheme).filter_by(id=id).first()

    def get_by_syllabus_id(self, syllabus_id: int) -> List[AssessmentScheme]:
        # Load components eagerly
        return self.session.query(AssessmentScheme).options(joinedload(AssessmentScheme.components)).filter_by(syllabus_id=syllabus_id).all()

    def create(self, data: dict) -> AssessmentScheme:
        s = AssessmentScheme(**data)
        self.session.add(s)
        self.session.commit()
        self.session.refresh(s)
        return s

    def update(self, id: int, data: dict) -> Optional[AssessmentScheme]:
        s = self.get_by_id(id)
        if not s:
            return None
        for k, v in data.items():
            if hasattr(s, k):
                setattr(s, k, v)
        self.session.commit()
        self.session.refresh(s)
        return s

    def delete(self, id: int) -> bool:
        s = self.get_by_id(id)
        if not s:
            return False
        self.session.delete(s)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/clo_plo_mapping_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.clo_plo_mapping_model import CloPloMapping

class CloPloMappingRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[CloPloMapping]:
        return self.session.query(CloPloMapping).filter_by(id=id).first()

    def get_by_syllabus_clo(self, syllabus_clo_id: int) -> List[CloPloMapping]:
        return self.session.query(CloPloMapping).filter_by(syllabus_clo_id=syllabus_clo_id).all()

    def create(self, data: dict) -> CloPloMapping:
        item = CloPloMapping(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/department_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.department_model import Department

class DepartmentRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[Department]:
        return self.session.query(Department).all()

    def get_by_id(self, id: int) -> Optional[Department]:
        return self.session.query(Department).filter_by(id=id).first()

    def create(self, data: dict) -> Department:
        department = Department(**data)
        self.session.add(department)
        self.session.commit()
        self.session.refresh(department)
        return department

    def update(self, id: int, data: dict) -> Optional[Department]:
        department = self.get_by_id(id)
        if not department:
            return None
        for key, value in data.items():
            if hasattr(department, key):
                setattr(department, key, value)
        self.session.commit()
        self.session.refresh(department)
        return department

    def delete(self, id: int) -> bool:
        department = self.get_by_id(id)
        if not department:
            return False
        self.session.delete(department)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/faculty_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.faculty_model import Faculty

class FacultyRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[Faculty]:
        return self.session.query(Faculty).all()

    def get_by_id(self, id: int) -> Optional[Faculty]:
        return self.session.query(Faculty).filter_by(id=id).first()

    def create(self, data: dict) -> Faculty:
        faculty = Faculty(**data)
        self.session.add(faculty)
        self.session.commit()
        self.session.refresh(faculty)
        return faculty

    def update(self, id: int, data: dict) -> Optional[Faculty]:
        faculty = self.get_by_id(id)
        if not faculty:
            return None
        for key, value in data.items():
            if hasattr(faculty, key):
                setattr(faculty, key, value)
        self.session.commit()
        self.session.refresh(faculty)
        return faculty

    def delete(self, id: int) -> bool:
        faculty = self.get_by_id(id)
        if not faculty:
            return False
        self.session.delete(faculty)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/file_repository.py">
from typing import Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.file_model import File

class FileRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[File]:
        return self.session.query(File).filter_by(id=id).first()

    def create(self, data: dict) -> File:
        file_record = File(**data)
        self.session.add(file_record)
        self.session.commit()
        self.session.refresh(file_record)
        return file_record

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/notification_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.notification_model import Notification

class NotificationRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_user(self, user_id: int, limit: int = 20, unread_only: bool = False) -> List[Notification]:
        query = self.session.query(Notification).filter_by(user_id=user_id)
        if unread_only:
            query = query.filter_by(is_read=False)
        return query.order_by(Notification.created_at.desc()).limit(limit).all()

    def create(self, data: dict) -> Notification:
        item = Notification(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def mark_as_read(self, id: int) -> bool:
        item = self.session.query(Notification).filter_by(id=id).first()
        if not item:
            return False
        item.is_read = True
        self.session.commit()
        return True

    def mark_all_as_read(self, user_id: int):
        self.session.query(Notification).filter_by(user_id=user_id, is_read=False).update({'is_read': True})
        self.session.commit()
</file>

<file path="src/infrastructure/repositories/program_outcome_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.program_outcome_model import ProgramOutcome

class ProgramOutcomeRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[ProgramOutcome]:
        return self.session.query(ProgramOutcome).filter_by(id=id).first()

    def get_by_program_id(self, program_id: int) -> List[ProgramOutcome]:
        return self.session.query(ProgramOutcome).filter_by(program_id=program_id).all()

    def create(self, data: dict) -> ProgramOutcome:
        item = ProgramOutcome(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def update(self, id: int, data: dict) -> Optional[ProgramOutcome]:
        item = self.get_by_id(id)
        if not item:
            return None
        for k, v in data.items():
            if hasattr(item, k):
                setattr(item, k, v)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/program_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.program_model import Program

class ProgramRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[Program]:
        return self.session.query(Program).all()

    def get_by_id(self, id: int) -> Optional[Program]:
        return self.session.query(Program).filter_by(id=id).first()

    def create(self, data: dict) -> Program:
        p = Program(**data)
        self.session.add(p)
        self.session.commit()
        self.session.refresh(p)
        return p

    def update(self, id: int, data: dict) -> Optional[Program]:
        p = self.get_by_id(id)
        if not p:
            return None
        for key, value in data.items():
            if hasattr(p, key):
                setattr(p, key, value)
        self.session.commit()
        self.session.refresh(p)
        return p

    def delete(self, id: int) -> bool:
        p = self.get_by_id(id)
        if not p:
            return False
        self.session.delete(p)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/role_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.role_model import Role

class RoleRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[Role]:
        return self.session.query(Role).all()

    def get_by_id(self, id: int) -> Optional[Role]:
        return self.session.query(Role).filter_by(id=id).first()

    def get_by_name(self, name: str) -> Optional[Role]:
        return self.session.query(Role).filter_by(name=name).first()

    def create(self, data: dict) -> Role:
        role = Role(**data)
        self.session.add(role)
        self.session.commit()
        self.session.refresh(role)
        return role

    def delete(self, id: int) -> bool:
        role = self.get_by_id(id)
        if not role:
            return False
        self.session.delete(role)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/rubric_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.rubric_model import Rubric

class RubricRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[Rubric]:
        return self.session.query(Rubric).filter_by(id=id).first()

    def get_by_component_id(self, component_id: int) -> List[Rubric]:
        return self.session.query(Rubric).filter_by(component_id=component_id).all()

    def create(self, data: dict) -> Rubric:
        item = Rubric(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def update(self, id: int, data: dict) -> Optional[Rubric]:
        item = self.get_by_id(id)
        if not item:
            return None
        for k, v in data.items():
            if hasattr(item, k):
                setattr(item, k, v)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/student_report_repository.py">
from typing import List
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.student_report_model import StudentReport

class StudentReportRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def create(self, data: dict) -> StudentReport:
        item = StudentReport(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def get_all(self) -> List[StudentReport]:
        return self.session.query(StudentReport).all()

    def update_status(self, id: int, status: str, admin_note: str = None):
        item = self.session.query(StudentReport).filter_by(id=id).first()
        if item:
            item.status = status
            if admin_note: item.admin_note = admin_note
            self.session.commit()
            self.session.refresh(item)
        return item
</file>

<file path="src/infrastructure/repositories/student_subscription_repository.py">
from typing import List
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.student_subscription_model import StudentSubscription

class StudentSubscriptionRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def create(self, user_id: int, subject_id: int):
        # Check exists
        exists = self.session.query(StudentSubscription).filter_by(student_id=user_id, subject_id=subject_id).first()
        if exists: return exists
        
        item = StudentSubscription(student_id=user_id, subject_id=subject_id)
        self.session.add(item)
        self.session.commit()
        return item

    def delete(self, user_id: int, subject_id: int):
        item = self.session.query(StudentSubscription).filter_by(student_id=user_id, subject_id=subject_id).first()
        if item:
            self.session.delete(item)
            self.session.commit()
            return True
        return False

    def get_by_student(self, user_id: int) -> List[StudentSubscription]:
        return self.session.query(StudentSubscription).filter_by(student_id=user_id).all()
</file>

<file path="src/infrastructure/repositories/subject_relationship_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.subject_relationship_model import SubjectRelationship

class SubjectRelationshipRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[SubjectRelationship]:
        return self.session.query(SubjectRelationship).filter_by(id=id).first()

    def get_by_subject(self, subject_id: int) -> List[SubjectRelationship]:
        return self.session.query(SubjectRelationship).filter_by(subject_id=subject_id).all()

    def create(self, data: dict) -> SubjectRelationship:
        item = SubjectRelationship(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/subject_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.subject_model import Subject

class SubjectRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[Subject]:
        return self.session.query(Subject).all()

    def get_by_id(self, id: int) -> Optional[Subject]:
        return self.session.query(Subject).filter_by(id=id).first()

    def create(self, data: dict) -> Subject:
        subject = Subject(**data)
        self.session.add(subject)
        self.session.commit()
        self.session.refresh(subject)
        return subject

    def update(self, id: int, data: dict) -> Optional[Subject]:
        subject = self.get_by_id(id)
        if not subject:
            return None
        for key, value in data.items():
            if hasattr(subject, key):
                setattr(subject, key, value)
        self.session.commit()
        self.session.refresh(subject)
        return subject

    def delete(self, id: int) -> bool:
        subject = self.get_by_id(id)
        if not subject:
            return False
        self.session.delete(subject)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/syllabus_clo_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.syllabus_clo_model import SyllabusClo

class SyllabusCloRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[SyllabusClo]:
        return self.session.query(SyllabusClo).all()

    def get_by_id(self, id: int) -> Optional[SyllabusClo]:
        return self.session.query(SyllabusClo).filter_by(id=id).first()

    def get_by_syllabus_id(self, syllabus_id: int) -> List[SyllabusClo]:
        return self.session.query(SyllabusClo).filter_by(syllabus_id=syllabus_id).all()

    def create(self, data: dict) -> SyllabusClo:
        item = SyllabusClo(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def update(self, id: int, data: dict) -> Optional[SyllabusClo]:
        item = self.get_by_id(id)
        if not item:
            return None
        for k, v in data.items():
            if hasattr(item, k):
                setattr(item, k, v)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/syllabus_comment_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.syllabus_comment_model import SyllabusComment

class SyllabusCommentRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[SyllabusComment]:
        return self.session.query(SyllabusComment).filter_by(id=id).first()

    def get_by_syllabus(self, syllabus_id: int) -> List[SyllabusComment]:
        return self.session.query(SyllabusComment).filter_by(syllabus_id=syllabus_id).order_by(SyllabusComment.created_at.asc()).all()

    def create(self, data: dict) -> SyllabusComment:
        item = SyllabusComment(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def update(self, id: int, data: dict) -> Optional[SyllabusComment]:
        item = self.get_by_id(id)
        if not item:
            return None
        for k, v in data.items():
            if hasattr(item, k):
                setattr(item, k, v)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/syllabus_material_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.syllabus_material_model import SyllabusMaterial

class SyllabusMaterialRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[SyllabusMaterial]:
        return self.session.query(SyllabusMaterial).all()

    def get_by_id(self, id: int) -> Optional[SyllabusMaterial]:
        return self.session.query(SyllabusMaterial).filter_by(id=id).first()

    def get_by_syllabus_id(self, syllabus_id: int) -> List[SyllabusMaterial]:
        return self.session.query(SyllabusMaterial).filter_by(syllabus_id=syllabus_id).all()

    def create(self, data: dict) -> SyllabusMaterial:
        item = SyllabusMaterial(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/syllabus_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session, joinedload
from infrastructure.databases.mssql import session
from infrastructure.models.syllabus_model import Syllabus
from infrastructure.models.assessment_scheme_model import AssessmentScheme
from infrastructure.models.assessment_component_model import AssessmentComponent

class SyllabusRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[Syllabus]:
        return self.session.query(Syllabus).all()

    def get_by_id(self, id: int) -> Optional[Syllabus]:
        return self.session.query(Syllabus).filter_by(id=id).first()

    def get_by_subject_id(self, subject_id: int) -> List[Syllabus]:
        return self.session.query(Syllabus).filter_by(subject_id=subject_id).all()

    def get_details(self, id: int) -> Optional[Syllabus]:
        # Eagerly load related collections and nested components->rubrics
        return (
            self.session.query(Syllabus)
            .options(
                joinedload(Syllabus.clos),
                joinedload(Syllabus.materials),
                joinedload(Syllabus.teaching_plans),
                joinedload(Syllabus.assessment_schemes)
                    .joinedload(AssessmentScheme.components)
                    .joinedload(AssessmentComponent.rubrics),
            )
            .filter_by(id=id)
            .first()
        )

    def create(self, data: dict) -> Syllabus:
        s = Syllabus(**data)
        self.session.add(s)
        self.session.commit()
        self.session.refresh(s)
        return s

    def update(self, id: int, data: dict) -> Optional[Syllabus]:
        s = self.get_by_id(id)
        if not s:
            return None
        for key, value in data.items():
            if hasattr(s, key):
                setattr(s, key, value)
        self.session.commit()
        self.session.refresh(s)
        return s

    def delete(self, id: int) -> bool:
        s = self.get_by_id(id)
        if not s:
            return False
        self.session.delete(s)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/system_setting_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.system_setting_model import SystemSetting

class SystemSettingRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[SystemSetting]:
        return self.session.query(SystemSetting).all()

    def get_by_key(self, key: str) -> Optional[SystemSetting]:
        return self.session.query(SystemSetting).filter_by(key=key).first()

    def set_value(self, key: str, value: str, description: str = None, type: str = 'STRING') -> SystemSetting:
        setting = self.get_by_key(key)
        if setting:
            setting.value = value
            if description: setting.description = description
        else:
            setting = SystemSetting(key=key, value=value, type=type, description=description)
            self.session.add(setting)
        self.session.commit()
        self.session.refresh(setting)
        return setting
</file>

<file path="src/infrastructure/repositories/teaching_plan_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.teaching_plan_model import TeachingPlan

class TeachingPlanRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[TeachingPlan]:
        return self.session.query(TeachingPlan).filter_by(id=id).first()

    def get_by_syllabus_id(self, syllabus_id: int) -> List[TeachingPlan]:
        return self.session.query(TeachingPlan).filter_by(syllabus_id=syllabus_id).order_by(TeachingPlan.week).all()

    def create(self, data: dict) -> TeachingPlan:
        item = TeachingPlan(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def update(self, id: int, data: dict) -> Optional[TeachingPlan]:
        item = self.get_by_id(id)
        if not item:
            return None
        for k, v in data.items():
            if hasattr(item, k):
                setattr(item, k, v)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/user_repository.py">
from typing import List, Optional
from dotenv import load_dotenv
import os
from sqlalchemy.orm import Session
from infrastructure.databases import Base
from infrastructure.databases.mssql import session

# Import the User model
from infrastructure.models.user_model import User

load_dotenv()

class UserRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[User]:
        return self.session.query(User).all()

    def get_by_username(self, username: str) -> Optional[User]:
        return self.session.query(User).filter_by(username=username).first()

    def get_by_id(self, user_id: int) -> Optional[User]:
        return self.session.query(User).filter_by(id=user_id).first()

    def create(self, data: dict) -> User:
        user = User(**data)
        self.session.add(user)
        self.session.commit()
        self.session.refresh(user)
        return user

    def update(self, id: int, data: dict) -> Optional[User]:
        user = self.get_by_id(id)
        if not user:
            return None
        for key, value in data.items():
            if hasattr(user, key):
                setattr(user, key, value)
        self.session.commit()
        self.session.refresh(user)
        return user

    def delete(self, id: int) -> bool:
        user = self.get_by_id(id)
        if not user:
            return False
        self.session.delete(user)
        self.session.commit()
        return True
</file>

<file path="src/infrastructure/repositories/workflow_log_repository.py">
from typing import List
from infrastructure.models.workflow_log_model import WorkflowLog

class WorkflowLogRepository:
    def __init__(self, session):
        self.session = session

    def create(self, data: dict):
        wl = WorkflowLog(**data)
        self.session.add(wl)
        try:
            self.session.commit()
            self.session.refresh(wl)
            return wl
        except Exception:
            self.session.rollback()
            raise

    def get_by_syllabus_id(self, syllabus_id: int) -> List[WorkflowLog]:
        return self.session.query(WorkflowLog).filter_by(syllabus_id=syllabus_id).order_by(WorkflowLog.created_at.asc()).all()
</file>

<file path="src/infrastructure/services/...  # Services that use third party libraries or services (e.g. email service)">
# This file is intentionally left blank.
</file>

<file path="src/migrations">
# This directory contains database migration files.
</file>

<file path="src/README.md">
# Flask Clean Architecture

This project is structured using the Clean Architecture principles, which promotes separation of concerns and maintainability. Below is an overview of the project's structure and its components.

## Directory Structure

- **migrations/**: Contains database migration files.
- **scripts/**: Contains scripts for running and managing the application, such as `run_postgres.sh` for PostgreSQL.
- **api/**: Contains the API-related components.
  - **controllers/**: Controllers for handling API requests.
  - **schemas/**: Marshmallow schemas for data validation and serialization.
  - **middleware.py**: Middleware functions for processing requests and responses.
  - **responses.py**: Functions for handling API responses.
  - **requests.py**: Functions for handling API requests.
- **infrastructure/**: Contains components that interact with external systems.
  - **services/**: Services that use third-party libraries or services (e.g., email service).
  - **databases/**: Database adapters and initialization code.
  - **repositories/**: Repositories for interacting with the databases.
  - **models/**: Database models.
- **domain/**: Contains the core business logic.
  - **constants.py**: Constants used throughout the application.
  - **exceptions.py**: Custom exceptions for the application.
  - **models/**: Business logic models.
- **services/**: Services for interacting with the domain (business logic).
- **app.py**: The main entry point of the application, initializing the app and setting up routes.
- **config.py**: Configuration settings for the application.
- **cors.py**: Handles Cross-Origin Resource Sharing (CORS) settings.
- **create_app.py**: Factory function to create the Flask application instance.
- **dependency_container.py**: Manages dependency injection for the application.
- **error_handler.py**: Defines error handling logic for the application.
- **logging.py**: Sets up logging configurations for the application.

## Getting Started

To get started with the project, ensure you have the necessary dependencies installed and follow the setup instructions provided in the respective files. 

## Contributing

Contributions are welcome! Please follow the contribution guidelines outlined in the project documentation.
</file>

<file path="src/requirements.txt">
Flask>=2.0
Flask-Cors>=3.0
Flask-SQLAlchemy>=2.5
SQLAlchemy>=1.4
marshmallow>=3.0
pymssql>=2.2
python-dotenv>=0.21 
Flask-RESTX>=1.1.0 
flasgger
fastapi
apispec
apispec_webframeworks
flask-swagger-ui
dependency-injector>=4.0
PyJWT>=2.0
google-genai>=0.1
</file>

<file path="src/scripts/import_check.py">
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))  # apps/api/src
try:
    import services.syllabus_service as ss
    import services.ai_service as ai
    import api.schemas.syllabus_schema as sch
    import services.program_outcome_service as plo_svc
    import api.controllers.program_outcome_controller as plo_ctrl
    import services.file_service as file_svc
    import api.controllers.file_controller as file_ctrl
    import services.clo_plo_mapping_service as mapping_svc
    import api.controllers.clo_plo_mapping_controller as mapping_ctrl
    import services.subject_relationship_service as rel_svc
    import api.controllers.subject_relationship_controller as rel_ctrl
    import services.syllabus_comment_service as comment_svc
    import api.controllers.syllabus_comment_controller as comment_ctrl
    import services.notification_service as notif_svc
    import api.controllers.notification_controller as notif_ctrl
    import infrastructure.repositories.ai_auditlog_repository as audit_repo
    import services.system_setting_service as ss_svc
    import api.controllers.system_setting_controller as ss_ctrl
    import services.student_service as student_svc
    import api.controllers.student_controller as student_ctrl
    print('IMPORT_OK')
except Exception as e:
    print('IMPORT_FAIL', repr(e))
    raise
</file>

<file path="src/services/...  # Services for interacting with the domain (business logic)">
# This file is intentionally left blank.
</file>

<file path="src/services/academic_year_service.py">
from typing import List, Optional
from infrastructure.repositories.academic_year_repository import AcademicYearRepository

class AcademicYearService:
    def __init__(self, repository: AcademicYearRepository):
        self.repository = repository

    def list_academic_years(self) -> List:
        return self.repository.get_all()

    def get_academic_year(self, id: int):
        return self.repository.get_by_id(id)

    def create_academic_year(self, data: dict):
        return self.repository.create(data)

    def update_academic_year(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_academic_year(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/ai_service.py">
import os
import json
from datetime import datetime

# Prefer the new `google-genai` package (import path: `google.genai` via `from google import genai`).
# Fall back to legacy `google.generativeai` if needed for compatibility.
try:
    # New package (preferred)
    from google import genai
    _NEW_GENAI = True
except Exception:
    try:
        # Legacy package
        import google.generativeai as genai
        _NEW_GENAI = False
    except Exception:
        genai = None
        _NEW_GENAI = False

class AiService:
    def __init__(self, api_key: str = None, audit_repository=None):
        self.api_key = api_key or os.getenv('GEMINI_API_KEY')
        self.audit_repository = audit_repository

    def _log_usage(self, syllabus_id, action, in_tok, out_tok):
        if self.audit_repository and syllabus_id:
            try:
                self.audit_repository.create(syllabus_id, action, in_tok, out_tok)
            except Exception as e:
                print(f'Failed to log AI usage: {e}')

    def generate(self, subject_name: str, syllabus_id: int = None):
        if not self.api_key:
            return {"error": "Ch∆∞a c·∫•u h√¨nh GEMINI_API_KEY"}

        if genai is None:
            return {"error": "No generative AI client installed (install google-genai)"}

        # Strict Template
        json_template = {
            "subject_name_vi": subject_name,
            "subject_name_en": "...",
            "credits": 3,
            "time_allocation": { "theory": 30, "practice": 30, "self_study": 90 },
            "description": "...",
            "clos": [
                { "code": "CLO1", "description": "..." }
            ],
            "materials": [
                { "type": "MAIN", "title": "...", "author": "...", "publisher": "...", "isbn": "..." }
            ],
            "teaching_plans": [
                { "week": 1, "topic": "...", "activity": "...", "assessment": "..." }
            ],
            "assessment_schemes": [
                { 
                    "name": "Midterm", "weight": 50, 
                    "components": [
                        { "name": "Exam 1", "weight": 100, "rubrics": [{"criteria": "...", "max_score": 10}] }
                    ] 
                }
            ]
        }

        prompt = f"""
        You are a curriculum expert. Create a syllabus for: "{subject_name}".
        OUTPUT REQUIREMENT: Return ONLY valid raw JSON. No markdown, no explanations.
        The JSON structure MUST match this template exactly:
        {json.dumps(json_template, ensure_ascii=False)}
        """

        try:
            if _NEW_GENAI:
                # New `google-genai` client APIs can vary by version. Try several common interfaces defensively.
                # Some versions provide a module-level `configure` and helpers; others provide a `Client` class.
                if hasattr(genai, "configure"):
                    try:
                        genai.configure(api_key=self.api_key)
                    except Exception:
                        # Some versions accept different config methods ‚Äî ignore and continue to client creation
                        pass

                resp_text = None

                # Preferred: Client.generate_text(...) pattern
                if hasattr(genai, "Client"):
                    client = genai.Client()
                    response = client.generate_text(model="gemini-2.5-flash", input=prompt)
                    resp_text = getattr(response, "text", None)
                    if not resp_text and getattr(response, "candidates", None):
                        candidates = getattr(response, "candidates", [])
                        if candidates:
                            resp_text = getattr(candidates[0], "output", None) or getattr(candidates[0], "content", None)

                # Fallback: module-level generate_text
                if resp_text is None and hasattr(genai, "generate_text"):
                    response = genai.generate_text(model="gemini-2.5-flash", input=prompt)
                    resp_text = getattr(response, "text", None)
                    if not resp_text and getattr(response, "candidates", None):
                        candidates = getattr(response, "candidates", [])
                        if candidates:
                            resp_text = getattr(candidates[0], "output", None) or getattr(candidates[0], "content", None)

                # Last resort: string conversion
                if resp_text is None:
                    resp_text = str(response)

            else:
                # Legacy package behavior
                genai.configure(api_key=self.api_key)
                model = genai.GenerativeModel('gemini-2.5-flash')
                response = model.generate_content(prompt)
                resp_text = getattr(response, "text", "")

            clean_text = resp_text.replace("```json", "").replace("```", "").strip()
            # Simple token estimation (fallback if client does not provide usage)
            try:
                input_tokens = max(0, len(prompt.split()))
                output_tokens = max(0, len(clean_text.split()))
            except Exception:
                input_tokens = 0
                output_tokens = 0

            # Log usage if syllabus_id provided
            self._log_usage(syllabus_id, 'GENERATE', input_tokens, output_tokens)

            return json.loads(clean_text)
        except Exception as e:
            # Attempt to log error usage with zero tokens (if applicable)
            try:
                self._log_usage(syllabus_id, 'ERROR', 0, 0)
            except Exception:
                pass
            return {"error": str(e)}
</file>

<file path="src/services/assessment_clo_service.py">
from typing import List
from infrastructure.repositories.assessment_clo_repository import AssessmentCloRepository

class AssessmentCloService:
    def __init__(self, repository: AssessmentCloRepository, component_repository=None, syllabus_clo_repository=None, assessment_scheme_repository=None):
        self.repository = repository
        self.component_repository = component_repository
        self.syllabus_clo_repository = syllabus_clo_repository
        self.assessment_scheme_repository = assessment_scheme_repository

    def get_clos_for_component(self, component_id: int) -> List:
        return self.repository.get_clos_by_component(component_id)

    def add_mapping(self, component_id: int, syllabus_clo_id: int):
        component = self.component_repository.get_by_id(component_id)
        if not component:
            raise ValueError('Invalid component_id')
        syllabus_clo = self.syllabus_clo_repository.get_by_id(syllabus_clo_id)
        if not syllabus_clo:
            raise ValueError('Invalid syllabus_clo_id')

        # Determine the syllabus id for the component (via scheme relationship or scheme repository)
        comp_syllabus_id = None
        if getattr(component, 'scheme', None):
            comp_syllabus_id = component.scheme.syllabus_id
        elif hasattr(component, 'scheme_id'):
            if not self.assessment_scheme_repository:
                raise ValueError('Cannot determine component syllabus without assessment_scheme_repository')
            scheme = self.assessment_scheme_repository.get_by_id(component.scheme_id)
            if not scheme:
                raise ValueError('Invalid component: linked scheme not found')
            comp_syllabus_id = scheme.syllabus_id
        else:
            raise ValueError('Invalid component: cannot resolve related scheme')

        # Ensure both belong to the same syllabus
        if comp_syllabus_id != syllabus_clo.syllabus_id:
            raise ValueError('Cross-reference Error: Component and CLO must belong to the same Syllabus')

        return self.repository.add_mapping(component_id, syllabus_clo_id)

    def remove_mapping(self, component_id: int, syllabus_clo_id: int) -> bool:
        return self.repository.remove_mapping(component_id, syllabus_clo_id)
</file>

<file path="src/services/assessment_component_service.py">
from typing import Optional
from infrastructure.repositories.assessment_component_repository import AssessmentComponentRepository

class AssessmentComponentService:
    def __init__(self, repository: AssessmentComponentRepository, scheme_repository=None):
        self.repository = repository
        self.scheme_repository = scheme_repository

    def get_component(self, id: int):
        return self.repository.get_by_id(id)

    def create_component(self, data: dict):
        scheme_id = data.get('scheme_id')
        if not scheme_id or not self.scheme_repository.get_by_id(scheme_id):
            raise ValueError('Invalid scheme_id')
        return self.repository.create(data)

    def update_component(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_component(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/assessment_scheme_service.py">
from typing import List, Optional
from infrastructure.repositories.assessment_scheme_repository import AssessmentSchemeRepository

class AssessmentSchemeService:
    def __init__(self, repository: AssessmentSchemeRepository, syllabus_repository=None):
        self.repository = repository
        self.syllabus_repository = syllabus_repository

    def list_schemes_for_syllabus(self, syllabus_id: int) -> List:
        return self.repository.get_by_syllabus_id(syllabus_id)

    def get_scheme(self, id: int):
        return self.repository.get_by_id(id)

    def create_scheme(self, data: dict):
        syllabus_id = data.get('syllabus_id')
        if not syllabus_id or not self.syllabus_repository.get_by_id(syllabus_id):
            raise ValueError('Invalid syllabus_id')
        return self.repository.create(data)

    def update_scheme(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_scheme(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/clo_plo_mapping_service.py">
from typing import List
from infrastructure.repositories.clo_plo_mapping_repository import CloPloMappingRepository

class CloPloMappingService:
    def __init__(self, repository: CloPloMappingRepository, syllabus_clo_repository=None, program_outcome_repository=None):
        self.repository = repository
        self.syllabus_clo_repository = syllabus_clo_repository
        self.program_outcome_repository = program_outcome_repository

    def get_by_clo(self, clo_id: int) -> List:
        return self.repository.get_by_syllabus_clo(clo_id)

    def create_mapping(self, data: dict):
        clo_id = data.get('syllabus_clo_id')
        plo_id = data.get('program_plo_id')
        
        if not self.syllabus_clo_repository.get_by_id(clo_id):
            raise ValueError('Invalid syllabus_clo_id')
        if not self.program_outcome_repository.get_by_id(plo_id):
            raise ValueError('Invalid program_plo_id')
            
        return self.repository.create(data)

    def delete_mapping(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/department_service.py">
from typing import List, Optional
from infrastructure.repositories.department_repository import DepartmentRepository

class DepartmentService:
    def __init__(self, repository: DepartmentRepository):
        self.repository = repository

    def list_departments(self) -> List:
        return self.repository.get_all()

    def get_department(self, id: int):
        return self.repository.get_by_id(id)

    def create_department(self, data: dict):
        return self.repository.create(data)

    def update_department(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_department(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/faculty_service.py">
from typing import List, Optional
from infrastructure.repositories.faculty_repository import FacultyRepository

class FacultyService:
    def __init__(self, repository: FacultyRepository):
        self.repository = repository

    def list_faculties(self) -> List:
        return self.repository.get_all()

    def get_faculty(self, id: int):
        return self.repository.get_by_id(id)

    def create_faculty(self, data: dict):
        return self.repository.create(data)

    def update_faculty(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_faculty(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/file_service.py">
import os
import uuid
from werkzeug.utils import secure_filename
from infrastructure.repositories.file_repository import FileRepository

UPLOAD_FOLDER = 'static/uploads'
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif', 'doc', 'docx'}

class FileService:
    def __init__(self, repository: FileRepository):
        self.repository = repository
        if not os.path.exists(UPLOAD_FOLDER):
            os.makedirs(UPLOAD_FOLDER)

    def _allowed_file(self, filename):
        return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

    def upload_file(self, file_storage, uploader_id: int):
        if not file_storage or file_storage.filename == '':
            raise ValueError('No file selected')
        if not self._allowed_file(file_storage.filename):
            raise ValueError('File type not allowed')

        filename = secure_filename(file_storage.filename)
        unique_name = f"{uuid.uuid4()}_{filename}"
        file_path = os.path.join(UPLOAD_FOLDER, unique_name)
        
        # Save to disk
        file_storage.save(file_path)

        # Save to DB
        file_data = {
            'uploader_id': uploader_id,
            'file_name': filename,
            'file_path': file_path,
            'mime_type': file_storage.mimetype,
            'file_size': 0 # Optional: implement size check
        }
        return self.repository.create(file_data)
        
    def get_file(self, id: int):
        return self.repository.get_by_id(id)
</file>

<file path="src/services/notification_service.py">
from typing import List
from infrastructure.repositories.notification_repository import NotificationRepository

class NotificationService:
    def __init__(self, repository: NotificationRepository, user_repository=None):
        self.repository = repository
        self.user_repository = user_repository

    def get_user_notifications(self, user_id: int, unread_only: bool = False) -> List:
        return self.repository.get_by_user(user_id, unread_only=unread_only)

    def send_notification(self, user_id: int, title: str, message: str, link: str = None, type: str = 'SYSTEM'):
        if self.user_repository and not self.user_repository.get_by_id(user_id):
             raise ValueError('User not found')
        data = {
            'user_id': user_id,
            'title': title,
            'message': message,
            'link': link,
            'type': type,
            'is_read': False
        }
        return self.repository.create(data)

    def mark_read(self, id: int) -> bool:
        return self.repository.mark_as_read(id)

    def mark_all_read(self, user_id: int):
        return self.repository.mark_all_as_read(user_id)
</file>

<file path="src/services/program_outcome_service.py">
from typing import List
from infrastructure.repositories.program_outcome_repository import ProgramOutcomeRepository

class ProgramOutcomeService:
    def __init__(self, repository: ProgramOutcomeRepository, program_repository=None):
        self.repository = repository
        self.program_repository = program_repository

    def list_by_program(self, program_id: int) -> List:
        return self.repository.get_by_program_id(program_id)

    def create_plo(self, data: dict):
        program_id = data.get('program_id')
        if not program_id or not self.program_repository.get_by_id(program_id):
            raise ValueError('Invalid program_id')
        return self.repository.create(data)

    def update_plo(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_plo(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/program_service.py">
from typing import List, Optional
from infrastructure.repositories.program_repository import ProgramRepository

class ProgramService:
    def __init__(self, repository: ProgramRepository):
        self.repository = repository

    def list_programs(self) -> List:
        return self.repository.get_all()

    def get_program(self, id: int):
        return self.repository.get_by_id(id)

    def create_program(self, data: dict):
        return self.repository.create(data)

    def update_program(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_program(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/role_service.py">
from typing import List, Optional
from infrastructure.repositories.role_repository import RoleRepository

class RoleService:
    def __init__(self, repository: RoleRepository):
        self.repository = repository

    def list_roles(self) -> List:
        return self.repository.get_all()

    def get_role(self, id: int):
        return self.repository.get_by_id(id)

    def get_by_name(self, name: str):
        return self.repository.get_by_name(name)

    def create_role(self, data: dict):
        return self.repository.create(data)

    def delete_role(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/rubric_service.py">
from typing import List, Optional
from infrastructure.repositories.rubric_repository import RubricRepository

class RubricService:
    def __init__(self, repository: RubricRepository, component_repository=None):
        self.repository = repository
        self.component_repository = component_repository

    def list_rubrics_for_component(self, component_id: int) -> List:
        return self.repository.get_by_component_id(component_id)

    def get_rubric(self, id: int):
        return self.repository.get_by_id(id)

    def create_rubric(self, data: dict):
        component_id = data.get('component_id')
        if not component_id or not self.component_repository.get_by_id(component_id):
            raise ValueError('Invalid component_id')
        return self.repository.create(data)

    def update_rubric(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_rubric(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/student_service.py">
from typing import List
from infrastructure.repositories.student_subscription_repository import StudentSubscriptionRepository
from infrastructure.repositories.student_report_repository import StudentReportRepository

class StudentService:
    def __init__(self, sub_repo: StudentSubscriptionRepository, report_repo: StudentReportRepository):
        self.sub_repo = sub_repo
        self.report_repo = report_repo

    def subscribe(self, user_id: int, subject_id: int):
        return self.sub_repo.create(user_id, subject_id)

    def unsubscribe(self, user_id: int, subject_id: int):
        return self.sub_repo.delete(user_id, subject_id)

    def get_subscriptions(self, user_id: int):
        return self.sub_repo.get_by_student(user_id)

    def report_syllabus(self, user_id: int, syllabus_id: int, content: str):
        return self.report_repo.create({'student_id': user_id, 'syllabus_id': syllabus_id, 'content': content})

    def list_reports(self):
        return self.report_repo.get_all()

    def resolve_report(self, id: int, status: str, note: str = None):
        return self.report_repo.update_status(id, status, note)
</file>

<file path="src/services/subject_relationship_service.py">
from typing import List
from infrastructure.repositories.subject_relationship_repository import SubjectRelationshipRepository

class SubjectRelationshipService:
    def __init__(self, repository: SubjectRelationshipRepository, subject_repository=None):
        self.repository = repository
        self.subject_repository = subject_repository

    def get_relationships(self, subject_id: int) -> List:
        return self.repository.get_by_subject(subject_id)

    def add_relationship(self, data: dict):
        subject_id = data.get('subject_id')
        related_id = data.get('related_subject_id')
        
        if subject_id == related_id:
            raise ValueError('Subject cannot be related to itself')
        
        if not self.subject_repository.get_by_id(subject_id):
            raise ValueError('Invalid subject_id')
        if not self.subject_repository.get_by_id(related_id):
            raise ValueError('Invalid related_subject_id')
            
        return self.repository.create(data)

    def remove_relationship(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/subject_service.py">
from typing import List, Optional
from infrastructure.repositories.subject_repository import SubjectRepository

class SubjectService:
    def __init__(self, repository: SubjectRepository):
        self.repository = repository

    def list_subjects(self) -> List:
        return self.repository.get_all()

    def get_subject(self, id: int):
        return self.repository.get_by_id(id)

    def create_subject(self, data: dict):
        return self.repository.create(data)

    def update_subject(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_subject(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/syllabus_clo_service.py">
from typing import List, Optional
from infrastructure.repositories.syllabus_clo_repository import SyllabusCloRepository

class SyllabusCloService:
    def __init__(self, repository: SyllabusCloRepository, syllabus_repository=None):
        self.repository = repository
        self.syllabus_repository = syllabus_repository

    def list_clos(self) -> List:
        return self.repository.get_all()

    def get_clo(self, id: int):
        return self.repository.get_by_id(id)

    def get_by_syllabus(self, syllabus_id: int):
        return self.repository.get_by_syllabus_id(syllabus_id)

    def create_clo(self, data: dict):
        syllabus_id = data.get('syllabus_id')
        if not syllabus_id or not self.syllabus_repository.get_by_id(syllabus_id):
            raise ValueError('Invalid syllabus_id')
        return self.repository.create(data)

    def update_clo(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_clo(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/syllabus_comment_service.py">
from typing import List
from infrastructure.repositories.syllabus_comment_repository import SyllabusCommentRepository

class SyllabusCommentService:
    def __init__(self, repository: SyllabusCommentRepository, syllabus_repository=None, user_repository=None):
        self.repository = repository
        self.syllabus_repository = syllabus_repository
        self.user_repository = user_repository

    def get_comments(self, syllabus_id: int) -> List:
        return self.repository.get_by_syllabus(syllabus_id)

    def add_comment(self, data: dict):
        syllabus_id = data.get('syllabus_id')
        user_id = data.get('user_id')
        
        if not self.syllabus_repository.get_by_id(syllabus_id):
            raise ValueError('Invalid syllabus_id')
        if not self.user_repository.get_by_id(user_id):
            raise ValueError('Invalid user_id')
            
        return self.repository.create(data)

    def resolve_comment(self, id: int):
        return self.repository.update(id, {'is_resolved': True})

    def delete_comment(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/syllabus_material_service.py">
from typing import List, Optional
from infrastructure.repositories.syllabus_material_repository import SyllabusMaterialRepository

class SyllabusMaterialService:
    def __init__(self, repository: SyllabusMaterialRepository, syllabus_repository=None):
        self.repository = repository
        self.syllabus_repository = syllabus_repository

    def list_materials(self) -> List:
        return self.repository.get_all()

    def get_material(self, id: int):
        return self.repository.get_by_id(id)

    def get_by_syllabus(self, syllabus_id: int):
        return self.repository.get_by_syllabus_id(syllabus_id)

    def create_material(self, data: dict):
        syllabus_id = data.get('syllabus_id')
        if not syllabus_id or not self.syllabus_repository.get_by_id(syllabus_id):
            raise ValueError('Invalid syllabus_id')
        return self.repository.create(data)

    def delete_material(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/syllabus_service.py">
from typing import List, Optional
from infrastructure.repositories.syllabus_repository import SyllabusRepository

class SyllabusService:
    def __init__(self, repository: SyllabusRepository,
                 subject_repository=None,
                 program_repository=None,
                 academic_year_repository=None,
                 user_repository=None,
                 workflow_log_repository=None,
                 syllabus_clo_repository=None,
                 syllabus_material_repository=None,
                 teaching_plan_repository=None,
                 assessment_scheme_repository=None,
                 assessment_component_repository=None,
                 rubric_repository=None,
                 assessment_clo_repository=None):
        self.repository = repository
        self.subject_repository = subject_repository
        self.program_repository = program_repository
        self.academic_year_repository = academic_year_repository
        self.user_repository = user_repository
        self.workflow_log_repository = workflow_log_repository
        self.syllabus_clo_repository = syllabus_clo_repository
        self.syllabus_material_repository = syllabus_material_repository
        self.teaching_plan_repository = teaching_plan_repository
        self.assessment_scheme_repository = assessment_scheme_repository
        self.assessment_component_repository = assessment_component_repository
        self.rubric_repository = rubric_repository
        self.assessment_clo_repository = assessment_clo_repository

    def list_syllabuses(self) -> List:
        return self.repository.get_all()

    def get_syllabus(self, id: int):
        return self.repository.get_by_id(id)

    def get_syllabus_details(self, id: int):
        return self.repository.get_details(id)

    def get_by_subject(self, subject_id: int):
        return self.repository.get_by_subject_id(subject_id)

    def create_syllabus(self, data: dict):
        import json
        
        # Extract child data
        clos_data = data.pop('clos', [])
        materials_data = data.pop('materials', [])
        plans_data = data.pop('teaching_plans', [])
        schemes_data = data.pop('assessment_schemes', [])

        # Handle time_allocation (Dict -> JSON String)
        if 'time_allocation' in data and isinstance(data['time_allocation'], dict):
            data['time_allocation'] = json.dumps(data['time_allocation'])

        # Validate Foreign Keys
        subject_id = data.get('subject_id')
        if not subject_id or not self.subject_repository.get_by_id(subject_id):
            raise ValueError('Invalid subject_id')
        program_id = data.get('program_id')
        if not program_id or not self.program_repository.get_by_id(program_id):
            raise ValueError('Invalid program_id')
        academic_year_id = data.get('academic_year_id')
        if not academic_year_id or not self.academic_year_repository.get_by_id(academic_year_id):
            raise ValueError('Invalid academic_year_id')
        lecturer_id = data.get('lecturer_id')
        if not lecturer_id or not self.user_repository.get_by_id(lecturer_id):
            raise ValueError('Invalid lecturer_id')

        # Create Header
        data.setdefault('status', 'DRAFT')
        new_syllabus = self.repository.create(data)
        sid = new_syllabus.id

        # 1. Save CLOs
        if self.syllabus_clo_repository:
            for item in clos_data:
                item['syllabus_id'] = sid
                self.syllabus_clo_repository.create(item)

        # 2. Save Materials
        if self.syllabus_material_repository:
            for item in materials_data:
                item['syllabus_id'] = sid
                self.syllabus_material_repository.create(item)

        # 3. Save Teaching Plans
        if self.teaching_plan_repository:
            for item in plans_data:
                item['syllabus_id'] = sid
                self.teaching_plan_repository.create(item)

        # 4. Save Assessment Schemes (Nested)
        if self.assessment_scheme_repository:
            for scheme in schemes_data:
                components = scheme.pop('components', [])
                scheme['syllabus_id'] = sid
                new_scheme = self.assessment_scheme_repository.create(scheme)
                if self.assessment_component_repository:
                    for comp in components:
                        rubrics = comp.pop('rubrics', [])
                        comp['scheme_id'] = new_scheme.id
                        new_comp = self.assessment_component_repository.create(comp)
                        if self.rubric_repository:
                            for rub in rubrics:
                                rub['component_id'] = new_comp.id
                                self.rubric_repository.create(rub)

        return new_syllabus

    def update_syllabus(self, id: int, data: dict):
        # Check current status before allowing update
        s = self.repository.get_by_id(id)
        if not s:
            return None
        if s.status not in ('DRAFT', 'REJECTED'):
            raise ValueError(f"Cannot update syllabus in {s.status} status")
        return self.repository.update(id, data)

    def delete_syllabus(self, id: int) -> bool:
        return self.repository.delete(id)

    # Workflow methods
    def submit_syllabus(self, id: int, user_id: int):
        s = self.repository.get_by_id(id)
        if not s:
            return None
        
        current_status = (s.status or '').upper()
        if current_status not in ('DRAFT', 'REJECTED', 'RETURNED'):
             raise ValueError(f'Syllabus cannot be submitted in current status: {s.status}')
        
        from_status = s.status
        updated = self.repository.update(id, {'status': 'PENDING'})
        if self.workflow_log_repository:
            self.workflow_log_repository.create({
                'syllabus_id': id,
                'actor_id': user_id,
                'action': 'SUBMIT',
                'from_status': from_status,
                'to_status': 'PENDING',
                'comment': None
            })
        return updated

    def evaluate_syllabus(self, id: int, user_id: int, action: str, comment: Optional[str] = None):
        s = self.repository.get_by_id(id)
        if not s:
            return None
        action = action.upper()
        if action not in ('APPROVE', 'REJECT'):
            raise ValueError('Invalid action')
        from_status = s.status
        if action == 'APPROVE':
            new_status = 'APPROVED'
        else:  # REJECT
            if not comment:
                raise ValueError('Comment is required when rejecting')
            new_status = 'DRAFT'
        updated = self.repository.update(id, {'status': new_status})
        if self.workflow_log_repository:
            self.workflow_log_repository.create({
                'syllabus_id': id,
                'actor_id': user_id,
                'action': action,
                'from_status': from_status,
                'to_status': new_status,
                'comment': comment
            })
        return updated

    def get_workflow_logs(self, syllabus_id: int):
        if not self.workflow_log_repository:
            return []
        return self.workflow_log_repository.get_by_syllabus_id(syllabus_id)
</file>

<file path="src/services/system_setting_service.py">
from typing import List, Optional
from infrastructure.repositories.system_setting_repository import SystemSettingRepository

class SystemSettingService:
    def __init__(self, repository: SystemSettingRepository):
        self.repository = repository

    def get_all_settings(self) -> List:
        return self.repository.get_all()

    def update_setting(self, key: str, value: str, description: str = None):
        return self.repository.set_value(key, value, description)
</file>

<file path="src/services/teaching_plan_service.py">
from typing import List, Optional
from infrastructure.repositories.teaching_plan_repository import TeachingPlanRepository

class TeachingPlanService:
    def __init__(self, repository: TeachingPlanRepository, syllabus_repository=None):
        self.repository = repository
        self.syllabus_repository = syllabus_repository

    def list_plans_for_syllabus(self, syllabus_id: int) -> List:
        return self.repository.get_by_syllabus_id(syllabus_id)

    def get_plan(self, id: int):
        return self.repository.get_by_id(id)

    def create_teaching_plan(self, data: dict):
        syllabus_id = data.get('syllabus_id')
        if not syllabus_id or not self.syllabus_repository.get_by_id(syllabus_id):
            raise ValueError('Invalid syllabus_id')
        return self.repository.create(data)

    def update_teaching_plan(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_teaching_plan(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="src/services/user_service.py">
from typing import List, Optional
from werkzeug.security import generate_password_hash, check_password_hash
from infrastructure.repositories.user_repository import UserRepository

class UserService:
    def __init__(self, repository: UserRepository):
        self.repository = repository

    def list_users(self) -> List:
        return self.repository.get_all()

    def get_user(self, id: int):
        return self.repository.get_by_id(id)

    def get_by_username(self, username: str):
        return self.repository.get_by_username(username)

    def create_user(self, data: dict):
        # Hash password before saving
        if 'password' in data:
            data['password_hash'] = generate_password_hash(data.pop('password'))
        return self.repository.create(data)

    def update_user(self, id: int, data: dict):
        if 'password' in data:
            data['password_hash'] = generate_password_hash(data.pop('password'))
        return self.repository.update(id, data)

    def delete_user(self, id: int) -> bool:
        return self.repository.delete(id)

    def authenticate(self, username: str, password: str):
        user = self.get_by_username(username)
        if not user:
            return None
        if not check_password_hash(user.password_hash, password):
            return None
        return user
</file>

<file path="src/swagger_config.json">
{
    "template": {
        "swagger": "2.0",
        "info": {
            "title": "Syllabus Management API",
            "description": "API for Syllabus Management (SMD)",
            "version": "1.0.0"
        },
        "basePath": "/",
        "schemes": [
            "http",
            "https"
        ],
        "consumes": [
            "application/json"
        ],
        "produces": [
            "application/json"
        ]
    },
    "swagger_config": {
        "headers": [],
        "specs": [
            {
                "endpoint": "apispec",
                "route": "/apispec.json"
            }
        ],
        "static_url_path": "/flasgger_static",
        "swagger_ui": true,
        "specs_route": "/docs"
    }
}
</file>

<file path="src/tests/test_file_service.py">
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))  # apps/api/src

import os
import tempfile
from services.file_service import FileService, UPLOAD_FOLDER

class StubFileStorage:
    def __init__(self, filename, content=b"data", mimetype='application/octet-stream'):
        self.filename = filename
        self._content = content
        self.mimetype = mimetype

    def save(self, path):
        with open(path, 'wb') as f:
            f.write(self._content)


class StubRepo:
    def __init__(self):
        self.created = None
    def create(self, data):
        self.created = data
        class Item:
            def __init__(self, d):
                self.__dict__.update(d)
        return Item(data)


def test_upload_file_saves_to_disk_and_db(tmp_path, monkeypatch):
    # Use a temp upload folder
    tmp_dir = tmp_path / 'uploads'
    monkeypatch.setattr('services.file_service.UPLOAD_FOLDER', str(tmp_dir))

    repo = StubRepo()
    svc = FileService(repository=repo)

    file_storage = StubFileStorage('test.txt', b'hello', 'text/plain')
    record = svc.upload_file(file_storage, uploader_id=5)

    # Ensure file saved on disk
    assert os.path.exists(record.file_path)
    assert repo.created['uploader_id'] == 5
    assert repo.created['file_name'] == 'test.txt'


def test_upload_rejects_bad_extension():
    repo = StubRepo()
    svc = FileService(repository=repo)
    file_storage = StubFileStorage('test.exe')
    try:
        svc.upload_file(file_storage, uploader_id=1)
        assert False, 'Should raise ValueError for disallowed extension'
    except ValueError:
        pass
</file>

<file path="src/tests/test_program_outcome_service.py">
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))  # apps/api/src

from services.program_outcome_service import ProgramOutcomeService

class StubRepo:
    def __init__(self):
        self.created = {}
    def create(self, data):
        self.created = data
        return data
    def update(self, id, data):
        return {'id': id, **data}
    def delete(self, id):
        return True

class StubProgramRepo:
    def __init__(self, exists=True):
        self.exists = exists
    def get_by_id(self, id):
        return {'id': id} if self.exists else None


def test_create_plo_requires_valid_program():
    repo = StubRepo()
    program_repo = StubProgramRepo(exists=False)
    svc = ProgramOutcomeService(repository=repo, program_repository=program_repo)
    try:
        svc.create_plo({'program_id': 1, 'code': 'PLO1', 'description': 'd'})
        assert False, 'Should have raised ValueError'
    except ValueError:
        pass

    program_repo = StubProgramRepo(exists=True)
    svc = ProgramOutcomeService(repository=repo, program_repository=program_repo)
    item = svc.create_plo({'program_id': 1, 'code': 'PLO1', 'description': 'd'})
    assert repo.created['code'] == 'PLO1'


def test_update_and_delete_delegates_to_repo():
    repo = StubRepo()
    svc = ProgramOutcomeService(repository=repo)
    updated = svc.update_plo(1, {'code': 'X'})
    assert updated['id'] == 1
    assert svc.delete_plo(1) is True
</file>

<file path="src/tests/test_smoke_imports.py">
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))  # apps/api/src

from dependency_container import Container
from services.syllabus_service import SyllabusService
from services.program_outcome_service import ProgramOutcomeService
from services.file_service import FileService


def test_container_has_services():
    c = Container()
    assert hasattr(c, 'syllabus_service')
    assert hasattr(c, 'program_outcome_service')
    assert hasattr(c, 'file_service')


def test_service_classes_importable():
    assert callable(SyllabusService)
    assert callable(ProgramOutcomeService)
    assert callable(FileService)
</file>

<file path="src/tests/test_syllabus_service.py">
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))  # apps/api/src

import json
from services.syllabus_service import SyllabusService


class StubRepo:
    def __init__(self):
        self.created = []

    def create(self, data):
        # simulate DB model with id and status
        class Item:
            pass
        item = Item()
        item.id = 123
        item.status = data.get('status', 'DRAFT')
        self.created.append(data)
        return item

    def get_by_id(self, id):
        return None


class StubFKRepo:
    def __init__(self, exists=True):
        self.exists = exists

    def get_by_id(self, id):
        return {'id': id} if self.exists else None


class StubChildRepo:
    def __init__(self):
        self.items = []

    def create(self, data):
        self.items.append(data)
        class Item:
            def __init__(self, data, id):
                self.__dict__.update(data)
                self.id = id
        return Item(data, len(self.items))


def test_create_syllabus_creates_child_entities_and_serializes_time_allocation():
    repo = StubRepo()
    subj = StubFKRepo(True)
    prog = StubFKRepo(True)
    ay = StubFKRepo(True)
    user = StubFKRepo(True)
    clo_repo = StubChildRepo()
    mat_repo = StubChildRepo()
    plan_repo = StubChildRepo()
    scheme_repo = StubChildRepo()
    comp_repo = StubChildRepo()
    rubric_repo = StubChildRepo()

    svc = SyllabusService(
        repository=repo,
        subject_repository=subj,
        program_repository=prog,
        academic_year_repository=ay,
        user_repository=user,
        syllabus_clo_repository=clo_repo,
        syllabus_material_repository=mat_repo,
        teaching_plan_repository=plan_repo,
        assessment_scheme_repository=scheme_repo,
        assessment_component_repository=comp_repo,
        rubric_repository=rubric_repo
    )

    payload = {
        'subject_id': 1,
        'program_id': 1,
        'academic_year_id': 1,
        'lecturer_id': 1,
        'time_allocation': {'theory': 10, 'practice': 20},
        'clos': [{'code': 'C1', 'description': 'desc'}],
        'materials': [{'type': 'MAIN', 'title': 't'}],
        'teaching_plans': [{'week': 1, 'topic': 't'}],
        'assessment_schemes': [
            {
                'name': 'Scheme1',
                'weight': 50,
                'components': [
                    {'name': 'Comp1', 'weight': 100, 'rubrics': [{'criteria': 'r', 'max_score': 10}]}
                ]
            }
        ]
    }

    result = svc.create_syllabus(payload.copy())
    # header created
    assert result.id == 123
    # child repos created
    assert len(clo_repo.items) == 1
    assert len(mat_repo.items) == 1
    assert len(plan_repo.items) == 1
    assert len(scheme_repo.items) == 1
    assert len(comp_repo.items) == 1
    assert len(rubric_repo.items) == 1

    # ensure time_allocation was serialized as JSON in the header create payload
    header_payload = repo.created[0]
    assert isinstance(header_payload['time_allocation'], str)
    parsed = json.loads(header_payload['time_allocation'])
    assert parsed['theory'] == 10


def test_submit_syllabus_allows_returned_case_insensitive():
    class GetRepo:
        def __init__(self, status):
            class Item:
                pass
            self.item = Item()
            self.item.status = status
        def get_by_id(self, id):
            return self.item
        def update(self, id, data):
            return data

    for status in ['returned', 'RETURNED', 'Returned']:
        repo = GetRepo(status)
        svc = SyllabusService(repository=repo)
        updated = svc.submit_syllabus(1, 2)
        assert updated == {'status': 'PENDING'}
</file>

<file path="tests/e2e_test_flow.py">
"""End-to-end happy-path test for Syllabus Management System

Run this script directly (python tests/e2e_test_flow.py).
Requires: requests, colorama

It will stop immediately and print an error in red if any step returns an unexpected status code.
"""

import sys
import time
import uuid
from datetime import date

import requests
import json
try:
    from colorama import Fore, Style, init as colorama_init
except Exception:
    print("Please install 'colorama' (pip install colorama) to run this script.")
    sys.exit(2)

colorama_init(autoreset=True)

BASE_URL = 'http://localhost:9999'


def log(step: str, message: str, status: str = 'INFO'):
    """Nicely print a log line.

    status: INFO, OK, FAIL
    """
    status = status.upper()
    if status == 'OK':
        color = Fore.GREEN
    elif status == 'FAIL':
        color = Fore.RED
    else:
        color = Fore.CYAN
    print(f"[{color}{status}{Style.RESET_ALL}] {step} - {message}")


def fail(step: str, message: str, resp=None):
    log(step, message, 'FAIL')
    if resp is not None:
        try:
            print(Fore.RED + resp.text)
        except Exception:
            pass
    sys.exit(1)


def expect_status(step: str, resp: requests.Response, expected: int):
    if resp.status_code != expected:
        fail(step, f"Expected HTTP {expected}, got {resp.status_code}", resp)
    log(step, f"HTTP {resp.status_code}", 'OK')


def post(path: str, json: dict, token: str = None):
    headers = {'Content-Type': 'application/json'}
    if token:
        headers['Authorization'] = f'Bearer {token}'
    return requests.post(BASE_URL + path, json=json, headers=headers)


def get(path: str, token: str = None):
    headers = {}
    if token:
        headers['Authorization'] = f'Bearer {token}'
    return requests.get(BASE_URL + path, headers=headers)


def run():
    # Step 1: Login admin
    step = '1. Login Admin'
    payload = {'username': 'admin', 'password': 'password123'}
    resp = post('/auth/login', payload)
    expect_status(step, resp, 200)
    token = resp.json().get('token')
    if not token:
        fail(step, 'No token returned', resp)
    log(step, 'Obtained token', 'OK')

    # Helper to generate short unique strings
    uid = str(uuid.uuid4())[:8]

    # Step 2: Create Faculty
    step = '2. Create Faculty'
    payload = {'code': f'E2E-FAC-{uid}', 'name': 'E2E Faculty'}
    resp = post('/faculties/', payload, token=token)
    expect_status(step, resp, 201)
    faculty_id = resp.json().get('id')

    # Step 3: Create Department
    step = '3. Create Department'
    payload = {'faculty_id': faculty_id, 'code': f'E2E-DEP-{uid}', 'name': 'E2E Department'}
    resp = post('/departments/', payload, token=token)
    expect_status(step, resp, 201)
    department_id = resp.json().get('id')

    # Step 4: Create Program
    step = '4. Create Program'
    payload = {'department_id': department_id, 'name': f'E2E Program {uid}', 'total_credits': 120}
    resp = post('/programs/', payload, token=token)
    expect_status(step, resp, 201)
    program_id = resp.json().get('id')

    # Step 5: Create Academic Year
    step = '5. Create Academic Year'
    payload = {'code': f'AY-{uid}', 'start_date': date.today().isoformat(), 'end_date': (date.today().replace(year=date.today().year + 1)).isoformat()}
    resp = post('/academic-years/', payload, token=token)
    expect_status(step, resp, 201)
    academic_year_id = resp.json().get('id')

    # Step 6: Create Lecturer (User)
    step = '6. Create Lecturer User'
    username = f'e2e_user_{uid}'
    payload = {'username': username, 'email': f'{username}@example.com', 'full_name': 'E2E Lecturer', 'password': 'pass1234'}
    resp = post('/users/', payload, token=token)
    expect_status(step, resp, 201)
    lecturer_id = resp.json().get('id')

    # Step 7: Create Subject
    step = '7. Create Subject'
    payload = {'department_id': department_id, 'code': f'E2E-SUB-{uid}', 'name_vi': 'E2E M√¥n h·ªçc', 'name_en': 'E2E Subject', 'credits': 3}
    resp = post('/subjects/', payload, token=token)
    expect_status(step, resp, 201)
    subject_id = resp.json().get('id')

    # Step 8: Create Syllabus (Draft)
    step = '8. Create Syllabus (Draft)'
    payload = {'subject_id': subject_id, 'program_id': program_id, 'academic_year_id': academic_year_id, 'lecturer_id': lecturer_id}
    resp = post('/syllabuses/', payload, token=token)
    expect_status(step, resp, 201)
    syllabus = resp.json()
    syllabus_id = syllabus.get('id')
    if syllabus.get('status') and syllabus.get('status') != 'DRAFT':
        fail(step, f"Expected status DRAFT, got {syllabus.get('status')}")

    # Step 9: Add CLO
    step = '9. Add CLO'
    payload = {'syllabus_id': syllabus_id, 'code': 'CLO-1', 'description': 'Understand basics of E2E.'}
    resp = post('/syllabus-clos/', payload, token=token)
    expect_status(step, resp, 201)
    clo_id = resp.json().get('id')

    # Step 10: Add Assessment Scheme
    step = '10. Add Assessment Scheme'
    payload = {'syllabus_id': syllabus_id, 'name': 'Progress Test', 'weight': 50}
    resp = post('/assessment-schemes/', payload, token=token)
    expect_status(step, resp, 201)
    scheme_id = resp.json().get('id')

    # Step 11: Add Assessment Component
    step = '11. Add Assessment Component'
    payload = {'scheme_id': scheme_id, 'name': 'Quiz 1', 'weight': 10}
    resp = post('/assessment-components/', payload, token=token)
    expect_status(step, resp, 201)
    component_id = resp.json().get('id')

    # Step 12: Map CLO to Component
    step = '12. Map CLO to Component'
    payload = {'assessment_component_id': component_id, 'syllabus_clo_id': clo_id}
    resp = post('/assessment-clos/', payload, token=token)
    expect_status(step, resp, 201)

    # Step 13: Verify Details
    step = '13. Verify Details'
    resp = get(f'/syllabuses/{syllabus_id}/details', token=token)
    expect_status(step, resp, 200)
    detail = resp.json()
    # Debug: dump details
    try:
        print(Fore.CYAN + json.dumps(detail, indent=2, ensure_ascii=False))
    except Exception:
        pass
    # Check CLO presence
    clos = detail.get('clos', [])
    if not any(c.get('id') == clo_id for c in clos):
        fail(step, 'CLO not found in syllabus details')
    # Check component presence inside assessment_schemes
    # API returns camelCase via BaseSchema; support both for robustness
    schemes = detail.get('assessmentSchemes') or detail.get('assessment_schemes', [])
    found_comp = False
    for s in schemes:
        for c in s.get('components', []):
            if c.get('id') == component_id:
                found_comp = True
                break
        if found_comp:
            break
    if not found_comp:
        fail(step, 'Component not found in syllabus details')
    log(step, 'CLO and Component found in syllabus details', 'OK')

    # Step 14: Submit Syllabus
    step = '14. Submit Syllabus'
    payload = {'user_id': lecturer_id}
    resp = post(f'/syllabuses/{syllabus_id}/submit', payload, token=token)
    expect_status(step, resp, 200)
    s = resp.json()
    if s.get('status') != 'PENDING':
        fail(step, f"Expected status PENDING, got {s.get('status')}")

    # Step 15: Approve Syllabus
    step = '15. Approve Syllabus'
    payload = {'action': 'APPROVE', 'user_id': lecturer_id}
    resp = post(f'/syllabuses/{syllabus_id}/evaluate', payload, token=token)
    expect_status(step, resp, 200)
    s = resp.json()
    if s.get('status') != 'APPROVED':
        fail(step, f"Expected status APPROVED, got {s.get('status')}")

    log('E2E', f'Successfully completed happy-path for syllabus {syllabus_id}', 'OK')


if __name__ == '__main__':
    try:
        run()
    except requests.exceptions.ConnectionError as e:
        print(Fore.RED + 'Failed to connect to API at ' + BASE_URL)
        print(str(e))
        sys.exit(2)
</file>

</files>
